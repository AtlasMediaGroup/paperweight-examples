From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taah <admin@taah.dev>
Date: Thu, 9 May 2024 23:28:12 -0700
Subject: [PATCH] Add spectator teleport event


diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 5e9202bc7fc649764568b55d66ba0d684118c00c..536d165dfd2fda60548dbc3806e51195c4b1cb54 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -6,29 +6,15 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.brigadier.ParseResults;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.adventure.ChatProcessor;
+import io.papermc.paper.adventure.PaperAdventure;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import java.net.SocketAddress;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CompletableFuture;
-import java.util.function.BiFunction;
-import java.util.function.Consumer;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
+import me.totalfreedom.scissors.event.player.SpectatorTeleportEvent;
 import net.minecraft.ChatFormatting;
 import net.minecraft.Util;
 import net.minecraft.advancements.AdvancementHolder;
@@ -44,89 +30,12 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.Connection;
 import net.minecraft.network.TickablePacketListener;
-import net.minecraft.network.chat.ChatDecorator;
-import net.minecraft.network.chat.ChatType;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.LastSeenMessages;
-import net.minecraft.network.chat.LastSeenMessagesValidator;
-import net.minecraft.network.chat.MessageSignature;
-import net.minecraft.network.chat.MessageSignatureCache;
-import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.network.chat.PlayerChatMessage;
-import net.minecraft.network.chat.RemoteChatSession;
-import net.minecraft.network.chat.SignableCommand;
-import net.minecraft.network.chat.SignedMessageBody;
-import net.minecraft.network.chat.SignedMessageChain;
+import net.minecraft.network.chat.*;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketUtils;
 import net.minecraft.network.protocol.common.ServerboundClientInformationPacket;
-import net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket;
 import net.minecraft.network.protocol.configuration.ConfigurationProtocols;
-import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockChangedAckPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundCommandSuggestionsPacket;
-import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
-import net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket;
-import net.minecraft.network.protocol.game.ClientboundMoveVehiclePacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerChatPacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerPositionPacket;
-import net.minecraft.network.protocol.game.ClientboundSetCarriedItemPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
-import net.minecraft.network.protocol.game.ClientboundStartConfigurationPacket;
-import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
-import net.minecraft.network.protocol.game.ClientboundTagQueryPacket;
-import net.minecraft.network.protocol.game.ServerGamePacketListener;
-import net.minecraft.network.protocol.game.ServerboundAcceptTeleportationPacket;
-import net.minecraft.network.protocol.game.ServerboundBlockEntityTagQueryPacket;
-import net.minecraft.network.protocol.game.ServerboundChangeDifficultyPacket;
-import net.minecraft.network.protocol.game.ServerboundChatAckPacket;
-import net.minecraft.network.protocol.game.ServerboundChatCommandPacket;
-import net.minecraft.network.protocol.game.ServerboundChatCommandSignedPacket;
-import net.minecraft.network.protocol.game.ServerboundChatPacket;
-import net.minecraft.network.protocol.game.ServerboundChatSessionUpdatePacket;
-import net.minecraft.network.protocol.game.ServerboundChunkBatchReceivedPacket;
-import net.minecraft.network.protocol.game.ServerboundClientCommandPacket;
-import net.minecraft.network.protocol.game.ServerboundCommandSuggestionPacket;
-import net.minecraft.network.protocol.game.ServerboundConfigurationAcknowledgedPacket;
-import net.minecraft.network.protocol.game.ServerboundContainerButtonClickPacket;
-import net.minecraft.network.protocol.game.ServerboundContainerClickPacket;
-import net.minecraft.network.protocol.game.ServerboundContainerClosePacket;
-import net.minecraft.network.protocol.game.ServerboundContainerSlotStateChangedPacket;
-import net.minecraft.network.protocol.game.ServerboundDebugSampleSubscriptionPacket;
-import net.minecraft.network.protocol.game.ServerboundEditBookPacket;
-import net.minecraft.network.protocol.game.ServerboundEntityTagQueryPacket;
-import net.minecraft.network.protocol.game.ServerboundInteractPacket;
-import net.minecraft.network.protocol.game.ServerboundJigsawGeneratePacket;
-import net.minecraft.network.protocol.game.ServerboundLockDifficultyPacket;
-import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
-import net.minecraft.network.protocol.game.ServerboundMoveVehiclePacket;
-import net.minecraft.network.protocol.game.ServerboundPaddleBoatPacket;
-import net.minecraft.network.protocol.game.ServerboundPickItemPacket;
-import net.minecraft.network.protocol.game.ServerboundPlaceRecipePacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerAbilitiesPacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerCommandPacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerInputPacket;
-import net.minecraft.network.protocol.game.ServerboundRecipeBookChangeSettingsPacket;
-import net.minecraft.network.protocol.game.ServerboundRecipeBookSeenRecipePacket;
-import net.minecraft.network.protocol.game.ServerboundRenameItemPacket;
-import net.minecraft.network.protocol.game.ServerboundSeenAdvancementsPacket;
-import net.minecraft.network.protocol.game.ServerboundSelectTradePacket;
-import net.minecraft.network.protocol.game.ServerboundSetBeaconPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCommandBlockPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCommandMinecartPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCreativeModeSlotPacket;
-import net.minecraft.network.protocol.game.ServerboundSetJigsawBlockPacket;
-import net.minecraft.network.protocol.game.ServerboundSetStructureBlockPacket;
-import net.minecraft.network.protocol.game.ServerboundSignUpdatePacket;
-import net.minecraft.network.protocol.game.ServerboundSwingPacket;
-import net.minecraft.network.protocol.game.ServerboundTeleportToEntityPacket;
-import net.minecraft.network.protocol.game.ServerboundUseItemOnPacket;
-import net.minecraft.network.protocol.game.ServerboundUseItemPacket;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.network.protocol.ping.ClientboundPongResponsePacket;
 import net.minecraft.network.protocol.ping.ServerboundPingRequestPacket;
 import net.minecraft.resources.ResourceKey;
@@ -143,48 +52,25 @@ import net.minecraft.world.Container;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.effect.MobEffects;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.ExperienceOrb;
-import net.minecraft.world.entity.HasCustomInventoryScreen;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MoverType;
-import net.minecraft.world.entity.PlayerRideableJumping;
-import net.minecraft.world.entity.RelativeMovement;
+import net.minecraft.world.entity.*;
+import net.minecraft.world.entity.animal.Bucketable;
+import net.minecraft.world.entity.animal.allay.Allay;
+import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.ChatVisiblity;
 import net.minecraft.world.entity.player.Inventory;
 import net.minecraft.world.entity.player.ProfilePublicKey;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.entity.vehicle.Boat;
-import net.minecraft.world.inventory.AbstractContainerMenu;
-import net.minecraft.world.inventory.AnvilMenu;
-import net.minecraft.world.inventory.BeaconMenu;
-import net.minecraft.world.inventory.CrafterMenu;
-import net.minecraft.world.inventory.MerchantMenu;
-import net.minecraft.world.inventory.RecipeBookMenu;
-import net.minecraft.world.item.BlockItem;
-import net.minecraft.world.item.BucketItem;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
+import net.minecraft.world.inventory.*;
+import net.minecraft.world.item.*;
 import net.minecraft.world.item.component.CustomData;
 import net.minecraft.world.item.component.WritableBookContent;
 import net.minecraft.world.item.component.WrittenBookContent;
-import net.minecraft.world.level.BaseCommandBlock;
-import net.minecraft.world.level.ClipContext;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.GameType;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.LevelReader;
+import net.minecraft.world.item.crafting.RecipeHolder;
+import net.minecraft.world.level.*;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.CommandBlock;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.entity.CommandBlockEntity;
-import net.minecraft.world.level.block.entity.CrafterBlockEntity;
-import net.minecraft.world.level.block.entity.JigsawBlockEntity;
-import net.minecraft.world.level.block.entity.SignBlockEntity;
-import net.minecraft.world.level.block.entity.StructureBlockEntity;
-import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.entity.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
@@ -193,29 +79,12 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import io.papermc.paper.adventure.ChatProcessor; // Paper
-import io.papermc.paper.adventure.PaperAdventure; // Paper
-import com.mojang.datafixers.util.Pair;
-import java.util.Arrays;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Function;
-import net.minecraft.network.chat.OutgoingChatMessage;
-import net.minecraft.world.entity.animal.Bucketable;
-import net.minecraft.world.entity.animal.allay.Allay;
-import net.minecraft.world.entity.item.ItemEntity;
-import net.minecraft.world.inventory.Slot;
-import net.minecraft.world.item.crafting.RecipeHolder;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.inventory.CraftItemType;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.craftbukkit.util.LazyPlayerSet;
 import org.bukkit.craftbukkit.util.Waitable;
@@ -223,34 +92,32 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
 import org.bukkit.event.inventory.ClickType;
-import org.bukkit.event.inventory.CraftItemEvent;
-import org.bukkit.event.inventory.InventoryAction;
-import org.bukkit.event.inventory.InventoryClickEvent;
-import org.bukkit.event.inventory.InventoryCreativeEvent;
+import org.bukkit.event.inventory.*;
 import org.bukkit.event.inventory.InventoryType.SlotType;
-import org.bukkit.event.inventory.SmithItemEvent;
-import org.bukkit.event.player.AsyncPlayerChatEvent;
-import org.bukkit.event.player.PlayerAnimationEvent;
-import org.bukkit.event.player.PlayerAnimationType;
-import org.bukkit.event.player.PlayerChatEvent;
-import org.bukkit.event.player.PlayerCommandPreprocessEvent;
-import org.bukkit.event.player.PlayerInteractAtEntityEvent;
-import org.bukkit.event.player.PlayerInteractEntityEvent;
-import org.bukkit.event.player.PlayerItemHeldEvent;
-import org.bukkit.event.player.PlayerMoveEvent;
+import org.bukkit.event.player.*;
 import org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;
-import org.bukkit.event.player.PlayerSwapHandItemsEvent;
-import org.bukkit.event.player.PlayerTeleportEvent;
-import org.bukkit.event.player.PlayerToggleFlightEvent;
-import org.bukkit.event.player.PlayerToggleSneakEvent;
-import org.bukkit.event.player.PlayerToggleSprintEvent;
 import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.net.SocketAddress;
+import java.util.*;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 // CraftBukkit end
 
-public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl implements ServerGamePacketListener, ServerPlayerConnection, TickablePacketListener {
+public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl implements ServerGamePacketListener, ServerPlayerConnection, TickablePacketListener
+{
 
     static final Logger LOGGER = LogUtils.getLogger();
     private static final int NO_BLOCK_UPDATES_TO_ACK = -1;
@@ -266,7 +133,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // CraftBukkit start - multithreaded fields
     private final AtomicInteger chatSpamTickCount = new AtomicInteger();
     private final java.util.concurrent.atomic.AtomicInteger tabSpamLimiter = new java.util.concurrent.atomic.AtomicInteger(); // Paper - configurable tab spam limits
-    private final java.util.concurrent.atomic.AtomicInteger recipeSpamPackets =  new java.util.concurrent.atomic.AtomicInteger(); // Paper - auto recipe limit
+    private final java.util.concurrent.atomic.AtomicInteger recipeSpamPackets = new java.util.concurrent.atomic.AtomicInteger(); // Paper - auto recipe limit
     // CraftBukkit end
     private int dropSpamTickCount;
     private double firstGoodX;
@@ -303,7 +170,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     private boolean waitingForSwitchToConfig;
     private static final int MAX_SIGN_LINE_LENGTH = Integer.getInteger("Paper.maxSignLength", 80); // Paper - Limit client sign length
 
-    public ServerGamePacketListenerImpl(MinecraftServer server, Connection connection, ServerPlayer player, CommonListenerCookie clientData) {
+    public ServerGamePacketListenerImpl(MinecraftServer server, Connection connection, ServerPlayer player, CommonListenerCookie clientData)
+    {
         super(server, connection, clientData, player); // CraftBukkit
         this.chunkSender = new PlayerChunkSender(connection.isMemoryConnection());
         this.player = player;
@@ -320,7 +188,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     private int lastTick = MinecraftServer.currentTick;
     private int allowedPlayerTicks = 1;
     private int lastDropTick = MinecraftServer.currentTick;
-    private int lastBookTick  = MinecraftServer.currentTick;
+    private int lastBookTick = MinecraftServer.currentTick;
     private int dropCount = 0;
 
     private boolean hasMoved = false;
@@ -333,8 +201,10 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // CraftBukkit end
 
     @Override
-    public void tick() {
-        if (this.ackBlockChangesUpTo > -1) {
+    public void tick()
+    {
+        if (this.ackBlockChangesUpTo > -1)
+        {
             this.send(new ClientboundBlockChangedAckPacket(this.ackBlockChangesUpTo));
             this.ackBlockChangesUpTo = -1;
         }
@@ -347,36 +217,47 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         this.player.absMoveTo(this.firstGoodX, this.firstGoodY, this.firstGoodZ, this.player.getYRot(), this.player.getXRot());
         ++this.tickCount;
         this.knownMovePacketCount = this.receivedMovePacketCount;
-        if (this.clientIsFloating && !this.player.isSleeping() && !this.player.isPassenger() && !this.player.isDeadOrDying()) {
-            if (++this.aboveGroundTickCount > this.getMaximumFlyingTicks(this.player)) {
+        if (this.clientIsFloating && !this.player.isSleeping() && !this.player.isPassenger() && !this.player.isDeadOrDying())
+        {
+            if (++this.aboveGroundTickCount > this.getMaximumFlyingTicks(this.player))
+            {
                 ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked for floating too long!", this.player.getName().getString());
                 this.disconnect(io.papermc.paper.configuration.GlobalConfiguration.get().messages.kick.flyingPlayer, org.bukkit.event.player.PlayerKickEvent.Cause.FLYING_PLAYER); // Paper - use configurable kick message & kick event cause
                 return;
             }
-        } else {
+        }
+        else
+        {
             this.clientIsFloating = false;
             this.aboveGroundTickCount = 0;
         }
 
         this.lastVehicle = this.player.getRootVehicle();
-        if (this.lastVehicle != this.player && this.lastVehicle.getControllingPassenger() == this.player) {
+        if (this.lastVehicle != this.player && this.lastVehicle.getControllingPassenger() == this.player)
+        {
             this.vehicleFirstGoodX = this.lastVehicle.getX();
             this.vehicleFirstGoodY = this.lastVehicle.getY();
             this.vehicleFirstGoodZ = this.lastVehicle.getZ();
             this.vehicleLastGoodX = this.lastVehicle.getX();
             this.vehicleLastGoodY = this.lastVehicle.getY();
             this.vehicleLastGoodZ = this.lastVehicle.getZ();
-            if (this.clientVehicleIsFloating && this.lastVehicle.getControllingPassenger() == this.player) {
-                if (++this.aboveGroundVehicleTickCount > this.getMaximumFlyingTicks(this.lastVehicle)) {
+            if (this.clientVehicleIsFloating && this.lastVehicle.getControllingPassenger() == this.player)
+            {
+                if (++this.aboveGroundVehicleTickCount > this.getMaximumFlyingTicks(this.lastVehicle))
+                {
                     ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked for floating a vehicle too long!", this.player.getName().getString());
                     this.disconnect(io.papermc.paper.configuration.GlobalConfiguration.get().messages.kick.flyingVehicle, org.bukkit.event.player.PlayerKickEvent.Cause.FLYING_VEHICLE); // Paper - use configurable kick message & kick event cause
                     return;
                 }
-            } else {
+            }
+            else
+            {
                 this.clientVehicleIsFloating = false;
                 this.aboveGroundVehicleTickCount = 0;
             }
-        } else {
+        }
+        else
+        {
             this.lastVehicle = null;
             this.clientVehicleIsFloating = false;
             this.aboveGroundVehicleTickCount = 0;
@@ -384,9 +265,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
         this.keepConnectionAlive();
         // CraftBukkit start
-        for (int spam; (spam = this.chatSpamTickCount.get()) > 0 && !this.chatSpamTickCount.compareAndSet(spam, spam - 1); ) ;
-        if (tabSpamLimiter.get() > 0) tabSpamLimiter.getAndDecrement(); // Paper - configurable tab spam limits
-        if (recipeSpamPackets.get() > 0) recipeSpamPackets.getAndDecrement(); // Paper - auto recipe limit
+        for (int spam; (spam = this.chatSpamTickCount.get()) > 0 && !this.chatSpamTickCount.compareAndSet(spam, spam - 1); )
+            ;
+        if (tabSpamLimiter.get() > 0)
+        {
+            tabSpamLimiter.getAndDecrement(); // Paper - configurable tab spam limits
+        }
+        if (recipeSpamPackets.get() > 0)
+        {
+            recipeSpamPackets.getAndDecrement(); // Paper - auto recipe limit
+        }
         /* Use thread-safe field access instead
         if (this.chatSpamTickCount > 0) {
             --this.chatSpamTickCount;
@@ -394,17 +282,20 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         */
         // CraftBukkit end
 
-        if (this.dropSpamTickCount > 0) {
+        if (this.dropSpamTickCount > 0)
+        {
             --this.dropSpamTickCount;
         }
 
-        if (this.player.getLastActionTime() > 0L && this.server.getPlayerIdleTimeout() > 0 && Util.getMillis() - this.player.getLastActionTime() > (long) this.server.getPlayerIdleTimeout() * 1000L * 60L && !this.player.wonGame) { // Paper - Prevent AFK kick while watching end credits
+        if (this.player.getLastActionTime() > 0L && this.server.getPlayerIdleTimeout() > 0 && Util.getMillis() - this.player.getLastActionTime() > (long) this.server.getPlayerIdleTimeout() * 1000L * 60L && !this.player.wonGame)
+        { // Paper - Prevent AFK kick while watching end credits
             this.player.resetLastActionTime(); // CraftBukkit - SPIGOT-854
             this.disconnect(Component.translatable("multiplayer.disconnect.idling"), org.bukkit.event.player.PlayerKickEvent.Cause.IDLING); // Paper - kick event cause
         }
 
         // Paper start - Prevent causing expired keys from impacting new joins
-        if (!hasLoggedExpiry && this.chatSession != null && this.chatSession.profilePublicKey().data().hasExpired()) {
+        if (!hasLoggedExpiry && this.chatSession != null && this.chatSession.profilePublicKey().data().hasExpired())
+        {
             LOGGER.info("Player profile key for {} has expired!", this.player.getName().getString());
             hasLoggedExpiry = true;
         }
@@ -412,19 +303,24 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     }
 
-    private int getMaximumFlyingTicks(Entity vehicle) {
+    private int getMaximumFlyingTicks(Entity vehicle)
+    {
         double d0 = vehicle.getGravity();
 
-        if (d0 < 9.999999747378752E-6D) {
+        if (d0 < 9.999999747378752E-6D)
+        {
             return Integer.MAX_VALUE;
-        } else {
+        }
+        else
+        {
             double d1 = 0.08D / d0;
 
             return Mth.ceil(80.0D * Math.max(d1, 1.0D));
         }
     }
 
-    public void resetPosition() {
+    public void resetPosition()
+    {
         this.firstGoodX = this.player.getX();
         this.firstGoodY = this.player.getY();
         this.firstGoodZ = this.player.getZ();
@@ -434,71 +330,91 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public boolean isAcceptingMessages() {
+    public boolean isAcceptingMessages()
+    {
         return this.connection.isConnected() && !this.waitingForSwitchToConfig;
     }
 
     @Override
-    public boolean shouldHandleMessage(Packet<?> packet) {
+    public boolean shouldHandleMessage(Packet<?> packet)
+    {
         return super.shouldHandleMessage(packet) ? true : this.waitingForSwitchToConfig && this.connection.isConnected() && packet instanceof ServerboundConfigurationAcknowledgedPacket;
     }
 
     @Override
-    protected GameProfile playerProfile() {
+    protected GameProfile playerProfile()
+    {
         return this.player.getGameProfile();
     }
 
-    private <T, R> CompletableFuture<R> filterTextPacket(T text, BiFunction<TextFilter, T, CompletableFuture<R>> filterer) {
-        return ((CompletableFuture) filterer.apply(this.player.getTextFilter(), text)).thenApply((object) -> {
-            if (!this.isAcceptingMessages()) {
+    private <T, R> CompletableFuture<R> filterTextPacket(T text, BiFunction<TextFilter, T, CompletableFuture<R>> filterer)
+    {
+        return ((CompletableFuture) filterer.apply(this.player.getTextFilter(), text)).thenApply((object) ->
+        {
+            if (!this.isAcceptingMessages())
+            {
                 ServerGamePacketListenerImpl.LOGGER.debug("Ignoring packet due to disconnection");
                 throw new CancellationException("disconnected");
-            } else {
+            }
+            else
+            {
                 return object;
             }
         });
     }
 
-    private CompletableFuture<FilteredText> filterTextPacket(String text) {
+    private CompletableFuture<FilteredText> filterTextPacket(String text)
+    {
         return this.filterTextPacket(text, TextFilter::processStreamMessage);
     }
 
-    private CompletableFuture<List<FilteredText>> filterTextPacket(List<String> texts) {
+    private CompletableFuture<List<FilteredText>> filterTextPacket(List<String> texts)
+    {
         return this.filterTextPacket(texts, TextFilter::processMessageBundle);
     }
 
     @Override
-    public void handlePlayerInput(ServerboundPlayerInputPacket packet) {
+    public void handlePlayerInput(ServerboundPlayerInputPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         this.player.setPlayerInput(packet.getXxa(), packet.getZza(), packet.isJumping(), packet.isShiftKeyDown());
     }
 
-    private static boolean containsInvalidValues(double x, double y, double z, float yaw, float pitch) {
+    private static boolean containsInvalidValues(double x, double y, double z, float yaw, float pitch)
+    {
         return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z) || !Floats.isFinite(pitch) || !Floats.isFinite(yaw);
     }
 
-    private static double clampHorizontal(double d) {
+    private static double clampHorizontal(double d)
+    {
         return Mth.clamp(d, -3.0E7D, 3.0E7D);
     }
 
-    private static double clampVertical(double d) {
+    private static double clampVertical(double d)
+    {
         return Mth.clamp(d, -2.0E7D, 2.0E7D);
     }
 
     @Override
-    public void handleMoveVehicle(ServerboundMoveVehiclePacket packet) {
+    public void handleMoveVehicle(ServerboundMoveVehiclePacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (ServerGamePacketListenerImpl.containsInvalidValues(packet.getX(), packet.getY(), packet.getZ(), packet.getYRot(), packet.getXRot())) {
+        if (ServerGamePacketListenerImpl.containsInvalidValues(packet.getX(), packet.getY(), packet.getZ(), packet.getYRot(), packet.getXRot()))
+        {
             this.disconnect(Component.translatable("multiplayer.disconnect.invalid_vehicle_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_VEHICLE_MOVEMENT); // Paper - kick event cause
-        } else {
+        }
+        else
+        {
             Entity entity = this.player.getRootVehicle();
             // Paper start - Don't allow vehicle movement from players while teleporting
-            if (this.awaitingPositionFromClient != null || this.player.isImmobile() || entity.isRemoved()) {
+            if (this.awaitingPositionFromClient != null || this.player.isImmobile() || entity.isRemoved())
+            {
                 return;
             }
             // Paper end - Don't allow vehicle movement from players while teleporting
 
-            if (entity != this.player && entity.getControllingPassenger() == this.player && entity == this.lastVehicle) {
+            if (entity != this.player && entity.getControllingPassenger() == this.player && entity == this.lastVehicle)
+            {
                 ServerLevel worldserver = this.player.serverLevel();
                 // CraftBukkit - store current player position
                 double prevX = this.player.getX();
@@ -507,12 +423,18 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 float prevYaw = this.player.getYRot();
                 float prevPitch = this.player.getXRot();
                 // CraftBukkit end
-                double d0 = entity.getX();final double fromX = d0; // Paper - OBFHELPER
-                double d1 = entity.getY();final double fromY = d1; // Paper - OBFHELPER
-                double d2 = entity.getZ();final double fromZ = d2; // Paper - OBFHELPER
-                double d3 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX()); final double toX = d3; // Paper - OBFHELPER
-                double d4 = ServerGamePacketListenerImpl.clampVertical(packet.getY()); final double toY = d4; // Paper - OBFHELPER
-                double d5 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ()); final double toZ = d5; // Paper - OBFHELPER
+                double d0 = entity.getX();
+                final double fromX = d0; // Paper - OBFHELPER
+                double d1 = entity.getY();
+                final double fromY = d1; // Paper - OBFHELPER
+                double d2 = entity.getZ();
+                final double fromZ = d2; // Paper - OBFHELPER
+                double d3 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX());
+                final double toX = d3; // Paper - OBFHELPER
+                double d4 = ServerGamePacketListenerImpl.clampVertical(packet.getY());
+                final double toY = d4; // Paper - OBFHELPER
+                double d5 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ());
+                final double toZ = d5; // Paper - OBFHELPER
                 float f = Mth.wrapDegrees(packet.getYRot());
                 float f1 = Mth.wrapDegrees(packet.getXRot());
                 double d6 = d3 - this.vehicleFirstGoodX;
@@ -537,20 +459,27 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 ++this.receivedMovePacketCount;
                 int i = this.receivedMovePacketCount - this.knownMovePacketCount;
-                if (i > Math.max(this.allowedPlayerTicks, 5)) {
+                if (i > Math.max(this.allowedPlayerTicks, 5))
+                {
                     ServerGamePacketListenerImpl.LOGGER.debug(this.player.getScoreboardName() + " is sending move packets too frequently (" + i + " packets since last tick)");
                     i = 1;
                 }
 
-                if (d10 > 0) {
+                if (d10 > 0)
+                {
                     this.allowedPlayerTicks -= 1;
-                } else {
+                }
+                else
+                {
                     this.allowedPlayerTicks = 20;
                 }
                 double speed;
-                if (this.player.getAbilities().flying) {
+                if (this.player.getAbilities().flying)
+                {
                     speed = this.player.getAbilities().flyingSpeed * 20f;
-                } else {
+                }
+                else
+                {
                     speed = this.player.getAbilities().walkingSpeed * 10f;
                 }
                 speed *= 2f; // TODO: Get the speed of the vehicle instead of the player
@@ -559,14 +488,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 if (this.player.level().paperConfig().chunks.preventMovingIntoUnloadedChunks && (
                     !worldserver.areChunksLoadedForMove(this.player.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(this.player.position()))) ||
                         !worldserver.areChunksLoadedForMove(entity.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(entity.position())))
-                    )) {
+                ))
+                {
                     this.connection.send(new ClientboundMoveVehiclePacket(entity));
                     return;
                 }
                 // Paper end - Prevent moving into unloaded chunks
 
-                if (d10 - d9 > Math.max(100.0D, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner()) {
-                // CraftBukkit end
+                if (d10 - d9 > Math.max(100.0D, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner())
+                {
+                    // CraftBukkit end
                     ServerGamePacketListenerImpl.LOGGER.warn("{} (vehicle of {}) moved too quickly! {},{},{}", new Object[]{entity.getName().getString(), this.player.getName().getString(), d6, d7, d8});
                     this.send(new ClientboundMoveVehiclePacket(entity));
                     return;
@@ -579,10 +510,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 d8 = d5 - this.vehicleLastGoodZ; // Paper - diff on change, used for checking large move vectors above
                 boolean flag1 = entity.verticalCollisionBelow;
 
-                if (entity instanceof LivingEntity) {
+                if (entity instanceof LivingEntity)
+                {
                     LivingEntity entityliving = (LivingEntity) entity;
 
-                    if (entityliving.onClimbable()) {
+                    if (entityliving.onClimbable())
+                    {
                         entityliving.resetFallDistance();
                     }
                 }
@@ -593,7 +526,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 d6 = d3 - entity.getX();
                 d7 = d4 - entity.getY();
-                if (d7 > -0.5D || d7 < 0.5D) {
+                if (d7 > -0.5D || d7 < 0.5D)
+                {
                     d7 = 0.0D;
                 }
 
@@ -601,7 +535,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 d10 = d6 * d6 + d7 * d7 + d8 * d8;
                 boolean flag2 = false;
 
-                if (d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold) { // Spigot
+                if (d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold)
+                { // Spigot
                     flag2 = true; // Paper - diff on change, this should be moved wrongly
                     ServerGamePacketListenerImpl.LOGGER.warn("{} (vehicle of {}) moved wrongly! {}", new Object[]{entity.getName().getString(), this.player.getName().getString(), Math.sqrt(d10)});
                 }
@@ -611,14 +546,17 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 // Paper start - optimise out extra getCubes
                 boolean teleportBack = flag2; // violating this is always a fail
-                if (!teleportBack) {
+                if (!teleportBack)
+                {
                     // note: only call after setLocation, or else getBoundingBox is wrong
                     AABB newBox = entity.getBoundingBox();
-                    if (didCollide || !oldBox.equals(newBox)) {
+                    if (didCollide || !oldBox.equals(newBox))
+                    {
                         teleportBack = this.hasNewCollision(worldserver, entity, oldBox, newBox);
                     } // else: no collision at all detected, why do we care?
                 }
-                if (teleportBack) { // Paper end - optimise out extra getCubes
+                if (teleportBack)
+                { // Paper end - optimise out extra getCubes
                     entity.absMoveTo(d0, d1, d2, f, f1);
                     this.player.absMoveTo(d0, d1, d2, this.player.getYRot(), this.player.getXRot()); // CraftBukkit
                     this.send(new ClientboundMoveVehiclePacket(entity));
@@ -627,7 +565,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 // CraftBukkit start - fire PlayerMoveEvent
                 Player player = this.getCraftPlayer();
-                if (!this.hasMoved) {
+                if (!this.hasMoved)
+                {
                     this.lastPosX = prevX;
                     this.lastPosY = prevY;
                     this.lastPosZ = prevZ;
@@ -651,7 +590,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
                 float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
 
-                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isImmobile()) {
+                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isImmobile())
+                {
                     this.lastPosX = to.getX();
                     this.lastPosY = to.getY();
                     this.lastPosZ = to.getZ();
@@ -663,7 +603,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                     this.cserver.getPluginManager().callEvent(event);
 
                     // If the event is cancelled we move the player back to their old location.
-                    if (event.isCancelled()) {
+                    if (event.isCancelled())
+                    {
                         this.teleport(from);
                         return;
                     }
@@ -671,14 +612,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                     // If a Plugin has changed the To destination then we teleport the Player
                     // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
                     // We only do this if the Event was not cancelled.
-                    if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                    if (!oldTo.equals(event.getTo()) && !event.isCancelled())
+                    {
                         this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN);
                         return;
                     }
 
                     // Check to see if the Players Location has some how changed during the call of the event.
                     // This can happen due to a plugin teleporting the player instead of using .setTo()
-                    if (!from.equals(this.getCraftPlayer().getLocation()) && this.justTeleported) {
+                    if (!from.equals(this.getCraftPlayer().getLocation()) && this.justTeleported)
+                    {
                         this.justTeleported = false;
                         return;
                     }
@@ -696,7 +639,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    private boolean noBlocksAround(Entity entity) {
+    private boolean noBlocksAround(Entity entity)
+    {
         // Paper start - stop using streams, this is already a known fixed problem in Entity#move
         AABB box = entity.getBoundingBox().inflate(0.0625D).expandTowards(0.0D, -0.55D, 0.0D);
         int minX = Mth.floor(box.minX);
@@ -709,12 +653,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         Level world = entity.level();
         BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos();
 
-        for (int y = minY; y <= maxY; ++y) {
-            for (int z = minZ; z <= maxZ; ++z) {
-                for (int x = minX; x <= maxX; ++x) {
+        for (int y = minY; y <= maxY; ++y)
+        {
+            for (int z = minZ; z <= maxZ; ++z)
+            {
+                for (int x = minX; x <= maxX; ++x)
+                {
                     pos.set(x, y, z);
                     BlockState type = world.getBlockStateIfLoaded(pos);
-                    if (type != null && !type.isAir()) {
+                    if (type != null && !type.isAir())
+                    {
                         return false;
                     }
                 }
@@ -726,10 +674,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleAcceptTeleportPacket(ServerboundAcceptTeleportationPacket packet) {
+    public void handleAcceptTeleportPacket(ServerboundAcceptTeleportationPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (packet.getId() == this.awaitingTeleport) {
-            if (this.awaitingPositionFromClient == null) {
+        if (packet.getId() == this.awaitingTeleport)
+        {
+            if (this.awaitingPositionFromClient == null)
+            {
                 this.disconnect(Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
                 return;
             }
@@ -738,7 +689,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             this.lastGoodX = this.awaitingPositionFromClient.x;
             this.lastGoodY = this.awaitingPositionFromClient.y;
             this.lastGoodZ = this.awaitingPositionFromClient.z;
-            if (this.player.isChangingDimension()) {
+            if (this.player.isChangingDimension())
+            {
                 this.player.hasChangedDimension();
             }
 
@@ -749,7 +701,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleRecipeBookSeenRecipePacket(ServerboundRecipeBookSeenRecipePacket packet) {
+    public void handleRecipeBookSeenRecipePacket(ServerboundRecipeBookSeenRecipePacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         Optional<? extends RecipeHolder<?>> optional = this.server.getRecipeManager().byKey(packet.getRecipe()); // CraftBukkit - decompile error
         ServerRecipeBook recipebookserver = this.player.getRecipeBook();
@@ -759,20 +712,24 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleRecipeBookChangeSettingsPacket(ServerboundRecipeBookChangeSettingsPacket packet) {
+    public void handleRecipeBookChangeSettingsPacket(ServerboundRecipeBookChangeSettingsPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         CraftEventFactory.callRecipeBookSettingsEvent(this.player, packet.getBookType(), packet.isOpen(), packet.isFiltering()); // CraftBukkit
         this.player.getRecipeBook().setBookSetting(packet.getBookType(), packet.isOpen(), packet.isFiltering());
     }
 
     @Override
-    public void handleSeenAdvancements(ServerboundSeenAdvancementsPacket packet) {
+    public void handleSeenAdvancements(ServerboundSeenAdvancementsPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (packet.getAction() == ServerboundSeenAdvancementsPacket.Action.OPENED_TAB) {
+        if (packet.getAction() == ServerboundSeenAdvancementsPacket.Action.OPENED_TAB)
+        {
             ResourceLocation minecraftkey = (ResourceLocation) Objects.requireNonNull(packet.getTab());
             AdvancementHolder advancementholder = this.server.getAdvancements().get(minecraftkey);
 
-            if (advancementholder != null) {
+            if (advancementholder != null)
+            {
                 this.player.getAdvancements().setSelectedTab(advancementholder);
             }
         }
@@ -782,24 +739,29 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // Paper start - AsyncTabCompleteEvent
     private static final java.util.concurrent.ExecutorService TAB_COMPLETE_EXECUTOR = java.util.concurrent.Executors.newFixedThreadPool(4,
         new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Tab Complete Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build());
+
     // Paper end - AsyncTabCompleteEvent
     @Override
-    public void handleCustomCommandSuggestions(ServerboundCommandSuggestionPacket packet) {
+    public void handleCustomCommandSuggestions(ServerboundCommandSuggestionPacket packet)
+    {
         // PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // Paper - AsyncTabCompleteEvent; run this async
         // CraftBukkit start
-        if (this.chatSpamTickCount.addAndGet(io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.tabSpamIncrement) > io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.tabSpamLimit && !this.server.getPlayerList().isOp(this.player.getGameProfile())) { // Paper - configurable tab spam limits
+        if (this.chatSpamTickCount.addAndGet(io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.tabSpamIncrement) > io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.tabSpamLimit && !this.server.getPlayerList().isOp(this.player.getGameProfile()))
+        { // Paper - configurable tab spam limits
             this.disconnect(Component.translatable("disconnect.spam"), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM); // Paper - Kick event cause
             return;
         }
         // CraftBukkit end
         // Paper start - Don't suggest if tab-complete is disabled
-        if (org.spigotmc.SpigotConfig.tabComplete < 0) {
+        if (org.spigotmc.SpigotConfig.tabComplete < 0)
+        {
             return;
         }
         // Paper end - Don't suggest if tab-complete is disabled
         // Paper start
         final int index;
-        if (packet.getCommand().length() > 64 && ((index = packet.getCommand().indexOf(' ')) == -1 || index >= 64)) {
+        if (packet.getCommand().length() > 64 && ((index = packet.getCommand().indexOf(' ')) == -1 || index >= 64))
+        {
             this.disconnect(Component.translatable("disconnect.spam"), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM);
             return;
         }
@@ -808,10 +770,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         TAB_COMPLETE_EXECUTOR.execute(() -> this.handleCustomCommandSuggestions0(packet));
     }
 
-    private void handleCustomCommandSuggestions0(final ServerboundCommandSuggestionPacket packet) {
+    private void handleCustomCommandSuggestions0(final ServerboundCommandSuggestionPacket packet)
+    {
         StringReader stringreader = new StringReader(packet.getCommand());
 
-        if (stringreader.canRead() && stringreader.peek() == '/') {
+        if (stringreader.canRead() && stringreader.peek() == '/')
+        {
             stringreader.skip();
         }
 
@@ -819,21 +783,29 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         event.callEvent();
         final List<com.destroystokyo.paper.event.server.AsyncTabCompleteEvent.Completion> completions = event.isCancelled() ? com.google.common.collect.ImmutableList.of() : event.completions();
         // If the event isn't handled, we can assume that we have no completions, and so we'll ask the server
-        if (!event.isHandled()) {
-            if (event.isCancelled()) {
+        if (!event.isHandled())
+        {
+            if (event.isCancelled())
+            {
                 return;
             }
 
             // This needs to be on main
             this.server.scheduleOnMain(() -> this.sendServerSuggestions(packet, stringreader));
-        } else if (!completions.isEmpty()) {
+        }
+        else if (!completions.isEmpty())
+        {
             final com.mojang.brigadier.suggestion.SuggestionsBuilder builder0 = new com.mojang.brigadier.suggestion.SuggestionsBuilder(packet.getCommand(), stringreader.getTotalLength());
             final com.mojang.brigadier.suggestion.SuggestionsBuilder builder = builder0.createOffset(builder0.getInput().lastIndexOf(' ') + 1);
-            for (final com.destroystokyo.paper.event.server.AsyncTabCompleteEvent.Completion completion : completions) {
+            for (final com.destroystokyo.paper.event.server.AsyncTabCompleteEvent.Completion completion : completions)
+            {
                 final Integer intSuggestion = com.google.common.primitives.Ints.tryParse(completion.suggestion());
-                if (intSuggestion != null) {
+                if (intSuggestion != null)
+                {
                     builder.suggest(intSuggestion, PaperAdventure.asVanilla(completion.tooltip()));
-                } else {
+                }
+                else
+                {
                     builder.suggest(completion.suggestion(), PaperAdventure.asVanilla(completion.tooltip()));
                 }
             }
@@ -841,39 +813,47 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             com.mojang.brigadier.suggestion.Suggestions suggestions = builder.buildFuture().join();
             com.destroystokyo.paper.event.brigadier.AsyncPlayerSendSuggestionsEvent suggestEvent = new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendSuggestionsEvent(this.getCraftPlayer(), suggestions, packet.getCommand());
             suggestEvent.setCancelled(suggestions.isEmpty());
-            if (suggestEvent.callEvent()) {
+            if (suggestEvent.callEvent())
+            {
                 this.connection.send(new ClientboundCommandSuggestionsPacket(packet.getId(), limitTo(suggestEvent.getSuggestions(), ServerGamePacketListenerImpl.MAX_COMMAND_SUGGESTIONS)));
             }
             // Paper end - Brigadier API
         }
     }
+
     // Paper start - brig API
-    private static Suggestions limitTo(final Suggestions suggestions, final int size) {
+    private static Suggestions limitTo(final Suggestions suggestions, final int size)
+    {
         return suggestions.getList().size() <= size ? suggestions : new Suggestions(suggestions.getRange(), suggestions.getList().subList(0, size));
     }
     // Paper end - brig API
 
-    private void sendServerSuggestions(final ServerboundCommandSuggestionPacket packet, final StringReader stringreader) {
+    private void sendServerSuggestions(final ServerboundCommandSuggestionPacket packet, final StringReader stringreader)
+    {
         // Paper end - AsyncTabCompleteEvent
         ParseResults<CommandSourceStack> parseresults = this.server.getCommands().getDispatcher().parse(stringreader, this.player.createCommandSourceStack());
         // Paper start - Handle non-recoverable exceptions
         if (!parseresults.getExceptions().isEmpty()
-            && parseresults.getExceptions().values().stream().anyMatch(e -> e instanceof io.papermc.paper.brigadier.TagParseCommandSyntaxException)) {
+            && parseresults.getExceptions().values().stream().anyMatch(e -> e instanceof io.papermc.paper.brigadier.TagParseCommandSyntaxException))
+        {
             this.disconnect(Component.translatable("disconnect.spam"), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM);
             return;
         }
         // Paper end - Handle non-recoverable exceptions
 
-        this.server.getCommands().getDispatcher().getCompletionSuggestions(parseresults).thenAccept((suggestions) -> {
+        this.server.getCommands().getDispatcher().getCompletionSuggestions(parseresults).thenAccept((suggestions) ->
+        {
             // Paper start - Don't tab-complete namespaced commands if send-namespaced is false
-            if (!org.spigotmc.SpigotConfig.sendNamespaced && suggestions.getRange().getStart() <= 1) {
+            if (!org.spigotmc.SpigotConfig.sendNamespaced && suggestions.getRange().getStart() <= 1)
+            {
                 suggestions.getList().removeIf(suggestion -> suggestion.getText().contains(":"));
             }
             // Paper end - Don't tab-complete namespaced commands if send-namespaced is false
             // Paper start - Brigadier API
             com.destroystokyo.paper.event.brigadier.AsyncPlayerSendSuggestionsEvent suggestEvent = new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendSuggestionsEvent(this.getCraftPlayer(), suggestions, packet.getCommand());
             suggestEvent.setCancelled(suggestions.isEmpty());
-            if (suggestEvent.callEvent()) {
+            if (suggestEvent.callEvent())
+            {
                 this.send(new ClientboundCommandSuggestionsPacket(packet.getId(), limitTo(suggestEvent.getSuggestions(), ServerGamePacketListenerImpl.MAX_COMMAND_SUGGESTIONS)));
             }
             // Paper end - Brigadier API
@@ -881,19 +861,26 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSetCommandBlock(ServerboundSetCommandBlockPacket packet) {
+    public void handleSetCommandBlock(ServerboundSetCommandBlockPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (!this.server.isCommandBlockEnabled()) {
+        if (!this.server.isCommandBlockEnabled())
+        {
             this.player.sendSystemMessage(Component.translatable("advMode.notEnabled"));
-        } else if (!this.player.canUseGameMasterBlocks() && (!this.player.isCreative() || !this.player.getBukkitEntity().hasPermission("minecraft.commandblock"))) { // Paper - command block permission
+        }
+        else if (!this.player.canUseGameMasterBlocks() && (!this.player.isCreative() || !this.player.getBukkitEntity().hasPermission("minecraft.commandblock")))
+        { // Paper - command block permission
             this.player.sendSystemMessage(Component.translatable("advMode.notAllowed"));
-        } else {
+        }
+        else
+        {
             BaseCommandBlock commandblocklistenerabstract = null;
             CommandBlockEntity tileentitycommand = null;
             BlockPos blockposition = packet.getPos();
             BlockEntity tileentity = this.player.level().getBlockEntity(blockposition);
 
-            if (tileentity instanceof CommandBlockEntity) {
+            if (tileentity instanceof CommandBlockEntity)
+            {
                 tileentitycommand = (CommandBlockEntity) tileentity;
                 commandblocklistenerabstract = tileentitycommand.getCommandBlock();
             }
@@ -901,13 +888,15 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             String s = packet.getCommand();
             boolean flag = packet.isTrackOutput();
 
-            if (commandblocklistenerabstract != null) {
+            if (commandblocklistenerabstract != null)
+            {
                 CommandBlockEntity.Mode tileentitycommand_type = tileentitycommand.getMode();
                 BlockState iblockdata = this.player.level().getBlockState(blockposition);
                 Direction enumdirection = (Direction) iblockdata.getValue(CommandBlock.FACING);
                 BlockState iblockdata1;
 
-                switch (packet.getMode()) {
+                switch (packet.getMode())
+                {
                     case SEQUENCE:
                         iblockdata1 = Blocks.CHAIN_COMMAND_BLOCK.defaultBlockState();
                         break;
@@ -921,7 +910,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 BlockState iblockdata2 = iblockdata1;
                 BlockState iblockdata3 = (BlockState) ((BlockState) iblockdata2.setValue(CommandBlock.FACING, enumdirection)).setValue(CommandBlock.CONDITIONAL, packet.isConditional());
 
-                if (iblockdata3 != iblockdata) {
+                if (iblockdata3 != iblockdata)
+                {
                     this.player.level().setBlock(blockposition, iblockdata3, 2);
                     tileentity.setBlockState(iblockdata3);
                     this.player.level().getChunkAt(blockposition).setBlockEntity(tileentity);
@@ -929,17 +919,20 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 commandblocklistenerabstract.setCommand(s);
                 commandblocklistenerabstract.setTrackOutput(flag);
-                if (!flag) {
+                if (!flag)
+                {
                     commandblocklistenerabstract.setLastOutput((Component) null);
                 }
 
                 tileentitycommand.setAutomatic(packet.isAutomatic());
-                if (tileentitycommand_type != packet.getMode()) {
+                if (tileentitycommand_type != packet.getMode())
+                {
                     tileentitycommand.onModeSwitch();
                 }
 
                 commandblocklistenerabstract.onUpdated();
-                if (!StringUtil.isNullOrEmpty(s)) {
+                if (!StringUtil.isNullOrEmpty(s))
+                {
                     this.player.sendSystemMessage(Component.translatable("advMode.setCommand.success", s));
                 }
             }
@@ -948,19 +941,27 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSetCommandMinecart(ServerboundSetCommandMinecartPacket packet) {
+    public void handleSetCommandMinecart(ServerboundSetCommandMinecartPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (!this.server.isCommandBlockEnabled()) {
+        if (!this.server.isCommandBlockEnabled())
+        {
             this.player.sendSystemMessage(Component.translatable("advMode.notEnabled"));
-        } else if (!this.player.canUseGameMasterBlocks() && (!this.player.isCreative() || !this.player.getBukkitEntity().hasPermission("minecraft.commandblock"))) { // Paper - command block permission
+        }
+        else if (!this.player.canUseGameMasterBlocks() && (!this.player.isCreative() || !this.player.getBukkitEntity().hasPermission("minecraft.commandblock")))
+        { // Paper - command block permission
             this.player.sendSystemMessage(Component.translatable("advMode.notAllowed"));
-        } else {
+        }
+        else
+        {
             BaseCommandBlock commandblocklistenerabstract = packet.getCommandBlock(this.player.level());
 
-            if (commandblocklistenerabstract != null) {
+            if (commandblocklistenerabstract != null)
+            {
                 commandblocklistenerabstract.setCommand(packet.getCommand());
                 commandblocklistenerabstract.setTrackOutput(packet.isTrackOutput());
-                if (!packet.isTrackOutput()) {
+                if (!packet.isTrackOutput())
+                {
                     commandblocklistenerabstract.setLastOutput((Component) null);
                 }
 
@@ -972,10 +973,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handlePickItem(ServerboundPickItemPacket packet) {
+    public void handlePickItem(ServerboundPickItemPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         // Paper start - validate pick item position
-        if (!(packet.getSlot() >= 0 && packet.getSlot() < this.player.getInventory().items.size())) {
+        if (!(packet.getSlot() >= 0 && packet.getSlot() < this.player.getInventory().items.size()))
+        {
             ServerGamePacketListenerImpl.LOGGER.warn("{} tried to set an invalid carried item", this.player.getName().getString());
             this.disconnect("Invalid hotbar selection (Hacking?)", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause
             return;
@@ -987,7 +990,10 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         int sourceSlot = packet.getSlot();
 
         io.papermc.paper.event.player.PlayerPickItemEvent event = new io.papermc.paper.event.player.PlayerPickItemEvent(bukkitPlayer, targetSlot, sourceSlot);
-        if (!event.callEvent()) return;
+        if (!event.callEvent())
+        {
+            return;
+        }
 
         this.player.getInventory().pickSlot(event.getSourceSlot(), event.getTargetSlot());
         // Paper end - Add PlayerPickItemEvent
@@ -997,12 +1003,15 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleRenameItem(ServerboundRenameItemPacket packet) {
+    public void handleRenameItem(ServerboundRenameItemPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         AbstractContainerMenu container = this.player.containerMenu;
 
-        if (container instanceof AnvilMenu containeranvil) {
-            if (!containeranvil.stillValid(this.player)) {
+        if (container instanceof AnvilMenu containeranvil)
+        {
+            if (!containeranvil.stillValid(this.player))
+            {
                 ServerGamePacketListenerImpl.LOGGER.debug("Player {} interacted with invalid menu {}", this.player, containeranvil);
                 return;
             }
@@ -1013,12 +1022,15 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSetBeaconPacket(ServerboundSetBeaconPacket packet) {
+    public void handleSetBeaconPacket(ServerboundSetBeaconPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         AbstractContainerMenu container = this.player.containerMenu;
 
-        if (container instanceof BeaconMenu containerbeacon) {
-            if (!this.player.containerMenu.stillValid(this.player)) {
+        if (container instanceof BeaconMenu containerbeacon)
+        {
+            if (!this.player.containerMenu.stillValid(this.player))
+            {
                 ServerGamePacketListenerImpl.LOGGER.debug("Player {} interacted with invalid menu {}", this.player, this.player.containerMenu);
                 return;
             }
@@ -1029,14 +1041,17 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSetStructureBlock(ServerboundSetStructureBlockPacket packet) {
+    public void handleSetStructureBlock(ServerboundSetStructureBlockPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.canUseGameMasterBlocks()) {
+        if (this.player.canUseGameMasterBlocks())
+        {
             BlockPos blockposition = packet.getPos();
             BlockState iblockdata = this.player.level().getBlockState(blockposition);
             BlockEntity tileentity = this.player.level().getBlockEntity(blockposition);
 
-            if (tileentity instanceof StructureBlockEntity) {
+            if (tileentity instanceof StructureBlockEntity)
+            {
                 StructureBlockEntity tileentitystructure = (StructureBlockEntity) tileentity;
 
                 tileentitystructure.setMode(packet.getMode());
@@ -1051,31 +1066,50 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 tileentitystructure.setShowBoundingBox(packet.isShowBoundingBox());
                 tileentitystructure.setIntegrity(packet.getIntegrity());
                 tileentitystructure.setSeed(packet.getSeed());
-                if (tileentitystructure.hasStructureName()) {
+                if (tileentitystructure.hasStructureName())
+                {
                     String s = tileentitystructure.getStructureName();
 
-                    if (packet.getUpdateType() == StructureBlockEntity.UpdateType.SAVE_AREA) {
-                        if (tileentitystructure.saveStructure()) {
+                    if (packet.getUpdateType() == StructureBlockEntity.UpdateType.SAVE_AREA)
+                    {
+                        if (tileentitystructure.saveStructure())
+                        {
                             this.player.displayClientMessage(Component.translatable("structure_block.save_success", s), false);
-                        } else {
+                        }
+                        else
+                        {
                             this.player.displayClientMessage(Component.translatable("structure_block.save_failure", s), false);
                         }
-                    } else if (packet.getUpdateType() == StructureBlockEntity.UpdateType.LOAD_AREA) {
-                        if (!tileentitystructure.isStructureLoadable()) {
+                    }
+                    else if (packet.getUpdateType() == StructureBlockEntity.UpdateType.LOAD_AREA)
+                    {
+                        if (!tileentitystructure.isStructureLoadable())
+                        {
                             this.player.displayClientMessage(Component.translatable("structure_block.load_not_found", s), false);
-                        } else if (tileentitystructure.placeStructureIfSameSize(this.player.serverLevel())) {
+                        }
+                        else if (tileentitystructure.placeStructureIfSameSize(this.player.serverLevel()))
+                        {
                             this.player.displayClientMessage(Component.translatable("structure_block.load_success", s), false);
-                        } else {
+                        }
+                        else
+                        {
                             this.player.displayClientMessage(Component.translatable("structure_block.load_prepare", s), false);
                         }
-                    } else if (packet.getUpdateType() == StructureBlockEntity.UpdateType.SCAN_AREA) {
-                        if (tileentitystructure.detectSize()) {
+                    }
+                    else if (packet.getUpdateType() == StructureBlockEntity.UpdateType.SCAN_AREA)
+                    {
+                        if (tileentitystructure.detectSize())
+                        {
                             this.player.displayClientMessage(Component.translatable("structure_block.size_success", s), false);
-                        } else {
+                        }
+                        else
+                        {
                             this.player.displayClientMessage(Component.translatable("structure_block.size_failure"), false);
                         }
                     }
-                } else {
+                }
+                else
+                {
                     this.player.displayClientMessage(Component.translatable("structure_block.invalid_structure_name", packet.getName()), false);
                 }
 
@@ -1087,14 +1121,17 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSetJigsawBlock(ServerboundSetJigsawBlockPacket packet) {
+    public void handleSetJigsawBlock(ServerboundSetJigsawBlockPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.canUseGameMasterBlocks()) {
+        if (this.player.canUseGameMasterBlocks())
+        {
             BlockPos blockposition = packet.getPos();
             BlockState iblockdata = this.player.level().getBlockState(blockposition);
             BlockEntity tileentity = this.player.level().getBlockEntity(blockposition);
 
-            if (tileentity instanceof JigsawBlockEntity) {
+            if (tileentity instanceof JigsawBlockEntity)
+            {
                 JigsawBlockEntity tileentityjigsaw = (JigsawBlockEntity) tileentity;
 
                 tileentityjigsaw.setName(packet.getName());
@@ -1112,13 +1149,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleJigsawGenerate(ServerboundJigsawGeneratePacket packet) {
+    public void handleJigsawGenerate(ServerboundJigsawGeneratePacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.canUseGameMasterBlocks()) {
+        if (this.player.canUseGameMasterBlocks())
+        {
             BlockPos blockposition = packet.getPos();
             BlockEntity tileentity = this.player.level().getBlockEntity(blockposition);
 
-            if (tileentity instanceof JigsawBlockEntity) {
+            if (tileentity instanceof JigsawBlockEntity)
+            {
                 JigsawBlockEntity tileentityjigsaw = (JigsawBlockEntity) tileentity;
 
                 tileentityjigsaw.generate(this.player.serverLevel(), packet.levels(), packet.keepJigsaws());
@@ -1128,20 +1168,24 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSelectTrade(ServerboundSelectTradePacket packet) {
+    public void handleSelectTrade(ServerboundSelectTradePacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         int i = packet.getItem();
         AbstractContainerMenu container = this.player.containerMenu;
 
-        if (container instanceof MerchantMenu containermerchant) {
+        if (container instanceof MerchantMenu containermerchant)
+        {
             // CraftBukkit start
             final org.bukkit.event.inventory.TradeSelectEvent tradeSelectEvent = CraftEventFactory.callTradeSelectEvent(this.player, i, containermerchant);
-            if (tradeSelectEvent.isCancelled()) {
+            if (tradeSelectEvent.isCancelled())
+            {
                 this.player.getBukkitEntity().updateInventory();
                 return;
             }
             // CraftBukkit end
-            if (!containermerchant.stillValid(this.player)) {
+            if (!containermerchant.stillValid(this.player))
+            {
                 ServerGamePacketListenerImpl.LOGGER.debug("Player {} interacted with invalid menu {}", this.player, containermerchant);
                 return;
             }
@@ -1153,17 +1197,21 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleEditBook(ServerboundEditBookPacket packet) {
+    public void handleEditBook(ServerboundEditBookPacket packet)
+    {
         // Paper start - Book size limits
-        if (!this.cserver.isPrimaryThread()) {
+        if (!this.cserver.isPrimaryThread())
+        {
             List<String> pageList = packet.pages();
             long byteTotal = 0;
             int maxBookPageSize = io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.bookSize.pageMax;
             double multiplier = Math.max(0.3D, Math.min(1D, io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.bookSize.totalMultiplier));
             long byteAllowed = maxBookPageSize;
-            for (String testString : pageList) {
+            for (String testString : pageList)
+            {
                 int byteLength = testString.getBytes(java.nio.charset.StandardCharsets.UTF_8).length;
-                if (byteLength > 256 * 4) {
+                if (byteLength > 256 * 4)
+                {
                     ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send a book with with a page too large!");
                     server.scheduleOnMain(() -> this.disconnect("Book too large!", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION)); // Paper - kick event cause
                     return;
@@ -1171,30 +1219,36 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 byteTotal += byteLength;
                 int length = testString.length();
                 int multibytes = 0;
-                if (byteLength != length) {
-                    for (char c : testString.toCharArray()) {
-                        if (c > 127) {
+                if (byteLength != length)
+                {
+                    for (char c : testString.toCharArray())
+                    {
+                        if (c > 127)
+                        {
                             multibytes++;
                         }
                     }
                 }
                 byteAllowed += (maxBookPageSize * Math.min(1, Math.max(0.1D, (double) length / 255D))) * multiplier;
 
-                if (multibytes > 1) {
+                if (multibytes > 1)
+                {
                     // penalize MB
                     byteAllowed -= multibytes;
                 }
             }
 
-            if (byteTotal > byteAllowed) {
-                ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send too large of a book. Book Size: " + byteTotal + " - Allowed:  "+ byteAllowed + " - Pages: " + pageList.size());
+            if (byteTotal > byteAllowed)
+            {
+                ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send too large of a book. Book Size: " + byteTotal + " - Allowed:  " + byteAllowed + " - Pages: " + pageList.size());
                 server.scheduleOnMain(() -> this.disconnect("Book too large!", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION)); // Paper - kick event cause
                 return;
             }
         }
         // Paper end - Book size limits
         // CraftBukkit start
-        if (this.lastBookTick + 20 > MinecraftServer.currentTick) {
+        if (this.lastBookTick + 20 > MinecraftServer.currentTick)
+        {
             server.scheduleOnMain(() -> this.disconnect("Book edited too quickly!", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION)); // Paper - kick event cause // Paper - Also ensure this is called on main
             return;
         }
@@ -1202,7 +1256,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // CraftBukkit end
         int i = packet.slot();
 
-        if (Inventory.isHotbarSlot(i) || i == 40) {
+        if (Inventory.isHotbarSlot(i) || i == 40)
+        {
             List<String> list = Lists.newArrayList();
             Optional<String> optional = packet.title();
 
@@ -1212,9 +1267,11 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
             Objects.requireNonNull(list);
             stream.forEach(list::add);
-            Consumer<List<FilteredText>> consumer = optional.isPresent() ? (list1) -> {
+            Consumer<List<FilteredText>> consumer = optional.isPresent() ? (list1) ->
+            {
                 this.signBook((FilteredText) list1.get(0), list1.subList(1, list1.size()), i);
-            } : (list1) -> {
+            } : (list1) ->
+            {
                 this.updateBookContents(list1, i);
             };
 
@@ -1222,13 +1279,15 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    private void updateBookContents(List<FilteredText> pages, int slotId) {
+    private void updateBookContents(List<FilteredText> pages, int slotId)
+    {
         // CraftBukkit start
         ItemStack handItem = this.player.getInventory().getItem(slotId);
         ItemStack itemstack = handItem.copy();
         // CraftBukkit end
 
-        if (itemstack.is(Items.WRITABLE_BOOK)) {
+        if (itemstack.is(Items.WRITABLE_BOOK))
+        {
             List<Filterable<String>> list1 = pages.stream().map(this::filterableFromOutgoing).toList();
 
             itemstack.set(DataComponents.WRITABLE_BOOK_CONTENT, new WritableBookContent(list1));
@@ -1236,14 +1295,17 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    private void signBook(FilteredText title, List<FilteredText> pages, int slotId) {
+    private void signBook(FilteredText title, List<FilteredText> pages, int slotId)
+    {
         ItemStack itemstack = this.player.getInventory().getItem(slotId);
 
-        if (itemstack.is(Items.WRITABLE_BOOK)) {
+        if (itemstack.is(Items.WRITABLE_BOOK))
+        {
             ItemStack itemstack1 = itemstack.transmuteCopy(Items.WRITTEN_BOOK, 1);
 
             itemstack1.remove(DataComponents.WRITABLE_BOOK_CONTENT);
-            List<Filterable<Component>> list1 = (List<Filterable<Component>>) (List) pages.stream().map((filteredtext1) -> { // CraftBukkit - decompile error
+            List<Filterable<Component>> list1 = (List<Filterable<Component>>) (List) pages.stream().map((filteredtext1) ->
+            { // CraftBukkit - decompile error
                 return this.filterableFromOutgoing(filteredtext1).map(Component::literal);
             }).toList();
 
@@ -1253,17 +1315,21 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    private Filterable<String> filterableFromOutgoing(FilteredText message) {
+    private Filterable<String> filterableFromOutgoing(FilteredText message)
+    {
         return this.player.isTextFilteringEnabled() ? Filterable.passThrough(message.filteredOrEmpty()) : Filterable.from(message);
     }
 
     @Override
-    public void handleEntityTagQuery(ServerboundEntityTagQueryPacket packet) {
+    public void handleEntityTagQuery(ServerboundEntityTagQueryPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.hasPermissions(2)) {
+        if (this.player.hasPermissions(2))
+        {
             Entity entity = this.player.level().getEntity(packet.getEntityId());
 
-            if (entity != null) {
+            if (entity != null)
+            {
                 CompoundTag nbttagcompound = entity.saveWithoutId(new CompoundTag());
 
                 this.player.connection.send(new ClientboundTagQueryPacket(packet.getTransactionId(), nbttagcompound));
@@ -1273,16 +1339,20 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleContainerSlotStateChanged(ServerboundContainerSlotStateChangedPacket packet) {
+    public void handleContainerSlotStateChanged(ServerboundContainerSlotStateChangedPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (!this.player.isSpectator() && packet.containerId() == this.player.containerMenu.containerId) {
+        if (!this.player.isSpectator() && packet.containerId() == this.player.containerMenu.containerId)
+        {
             AbstractContainerMenu container = this.player.containerMenu;
 
-            if (container instanceof CrafterMenu) {
+            if (container instanceof CrafterMenu)
+            {
                 CrafterMenu craftermenu = (CrafterMenu) container;
                 Container iinventory = craftermenu.getContainer();
 
-                if (iinventory instanceof CrafterBlockEntity) {
+                if (iinventory instanceof CrafterBlockEntity)
+                {
                     CrafterBlockEntity crafterblockentity = (CrafterBlockEntity) iinventory;
 
                     crafterblockentity.setSlotState(packet.slotId(), packet.newState());
@@ -1293,9 +1363,11 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleBlockEntityTagQuery(ServerboundBlockEntityTagQueryPacket packet) {
+    public void handleBlockEntityTagQuery(ServerboundBlockEntityTagQueryPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.hasPermissions(2)) {
+        if (this.player.hasPermissions(2))
+        {
             BlockEntity tileentity = this.player.level().getBlockEntity(packet.getPos());
             CompoundTag nbttagcompound = tileentity != null ? tileentity.saveWithoutMetadata(this.player.registryAccess()) : null;
 
@@ -1304,38 +1376,56 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleMovePlayer(ServerboundMovePlayerPacket packet) {
+    public void handleMovePlayer(ServerboundMovePlayerPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (ServerGamePacketListenerImpl.containsInvalidValues(packet.getX(0.0D), packet.getY(0.0D), packet.getZ(0.0D), packet.getYRot(0.0F), packet.getXRot(0.0F))) {
+        if (ServerGamePacketListenerImpl.containsInvalidValues(packet.getX(0.0D), packet.getY(0.0D), packet.getZ(0.0D), packet.getYRot(0.0F), packet.getXRot(0.0F)))
+        {
             this.disconnect(Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
-        } else {
+        }
+        else
+        {
             ServerLevel worldserver = this.player.serverLevel();
 
-            if (!this.player.wonGame && !this.player.isImmobile()) { // CraftBukkit
-                if (this.tickCount == 0) {
+            if (!this.player.wonGame && !this.player.isImmobile())
+            { // CraftBukkit
+                if (this.tickCount == 0)
+                {
                     this.resetPosition();
                 }
 
-                if (this.awaitingPositionFromClient != null) {
-                    if (false && this.tickCount - this.awaitingTeleportTime > 20) { // Paper - this will greatly screw with clients with > 1000ms RTT
+                if (this.awaitingPositionFromClient != null)
+                {
+                    if (false && this.tickCount - this.awaitingTeleportTime > 20)
+                    { // Paper - this will greatly screw with clients with > 1000ms RTT
                         this.awaitingTeleportTime = this.tickCount;
                         this.teleport(this.awaitingPositionFromClient.x, this.awaitingPositionFromClient.y, this.awaitingPositionFromClient.z, this.player.getYRot(), this.player.getXRot());
                     }
                     this.allowedPlayerTicks = 20; // CraftBukkit
 
-                } else {
+                }
+                else
+                {
                     this.awaitingTeleportTime = this.tickCount;
-                    double d0 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX(this.player.getX())); final double toX = d0; // Paper - OBFHELPER
-                    double d1 = ServerGamePacketListenerImpl.clampVertical(packet.getY(this.player.getY())); final double toY = d1; // Paper - OBFHELPER
-                    double d2 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ(this.player.getZ())); final double toZ = d2; // Paper - OBFHELPER
-                    float f = Mth.wrapDegrees(packet.getYRot(this.player.getYRot())); final float toYaw = f; // Paper - OBFHELPER
-                    float f1 = Mth.wrapDegrees(packet.getXRot(this.player.getXRot())); final float toPitch = f1; // Paper - OBFHELPER
-
-                    if (this.player.isPassenger()) {
+                    double d0 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX(this.player.getX()));
+                    final double toX = d0; // Paper - OBFHELPER
+                    double d1 = ServerGamePacketListenerImpl.clampVertical(packet.getY(this.player.getY()));
+                    final double toY = d1; // Paper - OBFHELPER
+                    double d2 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ(this.player.getZ()));
+                    final double toZ = d2; // Paper - OBFHELPER
+                    float f = Mth.wrapDegrees(packet.getYRot(this.player.getYRot()));
+                    final float toYaw = f; // Paper - OBFHELPER
+                    float f1 = Mth.wrapDegrees(packet.getXRot(this.player.getXRot()));
+                    final float toPitch = f1; // Paper - OBFHELPER
+
+                    if (this.player.isPassenger())
+                    {
                         this.player.absMoveTo(this.player.getX(), this.player.getY(), this.player.getZ(), f, f1);
                         this.player.serverLevel().getChunkSource().move(this.player);
                         this.allowedPlayerTicks = 20; // CraftBukkit
-                    } else {
+                    }
+                    else
+                    {
                         // CraftBukkit - Make sure the move is valid but then reset it for plugins to modify
                         double prevX = this.player.getX();
                         double prevY = this.player.getY();
@@ -1361,15 +1451,20 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                         d10 = Math.max(d10, (otherFieldX * otherFieldX + otherFieldY * otherFieldY + otherFieldZ * otherFieldZ) - 1);
                         // Paper end - fix large move vectors killing the server
 
-                        if (this.player.isSleeping()) {
-                            if (d10 > 1.0D) {
+                        if (this.player.isSleeping())
+                        {
+                            if (d10 > 1.0D)
+                            {
                                 this.teleport(this.player.getX(), this.player.getY(), this.player.getZ(), f, f1);
                             }
 
-                        } else {
+                        }
+                        else
+                        {
                             boolean flag = this.player.isFallFlying();
 
-                            if (worldserver.tickRateManager().runsNormally()) {
+                            if (worldserver.tickRateManager().runsNormally())
+                            {
                                 ++this.receivedMovePacketCount;
                                 int i = this.receivedMovePacketCount - this.knownMovePacketCount;
 
@@ -1378,28 +1473,37 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
                                 this.lastTick = (int) (System.currentTimeMillis() / 50);
 
-                                if (i > Math.max(this.allowedPlayerTicks, 5)) {
+                                if (i > Math.max(this.allowedPlayerTicks, 5))
+                                {
                                     ServerGamePacketListenerImpl.LOGGER.debug("{} is sending move packets too frequently ({} packets since last tick)", this.player.getName().getString(), i);
                                     i = 1;
                                 }
 
-                                if (packet.hasRot || d10 > 0) {
+                                if (packet.hasRot || d10 > 0)
+                                {
                                     this.allowedPlayerTicks -= 1;
-                                } else {
+                                }
+                                else
+                                {
                                     this.allowedPlayerTicks = 20;
                                 }
                                 double speed;
-                                if (this.player.getAbilities().flying) {
+                                if (this.player.getAbilities().flying)
+                                {
                                     speed = this.player.getAbilities().flyingSpeed * 20f;
-                                } else {
+                                }
+                                else
+                                {
                                     speed = this.player.getAbilities().walkingSpeed * 10f;
                                 }
                                 // Paper start - Prevent moving into unloaded chunks
-                                if (this.player.level().paperConfig().chunks.preventMovingIntoUnloadedChunks && (this.player.getX() != toX || this.player.getZ() != toZ) && !worldserver.areChunksLoadedForMove(this.player.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(this.player.position())))) {
+                                if (this.player.level().paperConfig().chunks.preventMovingIntoUnloadedChunks && (this.player.getX() != toX || this.player.getZ() != toZ) && !worldserver.areChunksLoadedForMove(this.player.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(this.player.position()))))
+                                {
                                     // Paper start - Add fail move event
                                     io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.MOVED_INTO_UNLOADED_CHUNK,
                                         toX, toY, toZ, toYaw, toPitch, false);
-                                    if (!event.isAllowed()) {
+                                    if (!event.isAllowed())
+                                    {
                                         this.internalTeleport(this.player.getX(), this.player.getY(), this.player.getZ(), this.player.getYRot(), this.player.getXRot(), Collections.emptySet());
                                         return;
                                     }
@@ -1407,17 +1511,22 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 }
                                 // Paper end - Prevent moving into unloaded chunks
 
-                                if (!this.player.isChangingDimension() && (!this.player.level().getGameRules().getBoolean(GameRules.RULE_DISABLE_ELYTRA_MOVEMENT_CHECK) || !flag)) {
+                                if (!this.player.isChangingDimension() && (!this.player.level().getGameRules().getBoolean(GameRules.RULE_DISABLE_ELYTRA_MOVEMENT_CHECK) || !flag))
+                                {
                                     float f2 = flag ? 300.0F : 100.0F;
 
-                                    if (d10 - d9 > Math.max(f2, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner()) {
-                                    // CraftBukkit end
+                                    if (d10 - d9 > Math.max(f2, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner())
+                                    {
+                                        // CraftBukkit end
                                         // Paper start - Add fail move event
                                         io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.MOVED_TOO_QUICKLY,
                                             toX, toY, toZ, toYaw, toPitch, true);
-                                        if (!event.isAllowed()) {
+                                        if (!event.isAllowed())
+                                        {
                                             if (event.getLogWarning())
+                                            {
                                                 ServerGamePacketListenerImpl.LOGGER.warn("{} moved too quickly! {},{},{}", new Object[]{this.player.getName().getString(), d6, d7, d8});
+                                            }
                                             this.teleport(this.player.getX(), this.player.getY(), this.player.getZ(), this.player.getYRot(), this.player.getXRot());
                                             return;
                                         }
@@ -1433,30 +1542,36 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             d8 = d2 - this.lastGoodZ; // Paper - diff on change, used for checking large move vectors above
                             boolean flag1 = d7 > 0.0D;
 
-                            if (this.player.onGround() && !packet.isOnGround() && flag1) {
+                            if (this.player.onGround() && !packet.isOnGround() && flag1)
+                            {
                                 // Paper start - Add PlayerJumpEvent
                                 Player player = this.getCraftPlayer();
                                 Location from = new Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
                                 Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
 
                                 // If the packet contains movement information then we update the To location with the correct XYZ.
-                                if (packet.hasPos) {
+                                if (packet.hasPos)
+                                {
                                     to.setX(packet.x);
                                     to.setY(packet.y);
                                     to.setZ(packet.z);
                                 }
 
                                 // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
-                                if (packet.hasRot) {
+                                if (packet.hasRot)
+                                {
                                     to.setYaw(packet.yRot);
                                     to.setPitch(packet.xRot);
                                 }
 
                                 com.destroystokyo.paper.event.player.PlayerJumpEvent event = new com.destroystokyo.paper.event.player.PlayerJumpEvent(player, from, to);
 
-                                if (event.callEvent()) {
+                                if (event.callEvent())
+                                {
                                     this.player.jumpFromGround();
-                                } else {
+                                }
+                                else
+                                {
                                     from = event.getFrom();
                                     this.internalTeleport(from.getX(), from.getY(), from.getZ(), from.getYaw(), from.getPitch(), Collections.emptySet());
                                     return;
@@ -1470,7 +1585,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             this.player.onGround = packet.isOnGround(); // CraftBukkit - SPIGOT-5810, SPIGOT-5835, SPIGOT-6828: reset by this.player.move
                             boolean didCollide = toX != this.player.getX() || toY != this.player.getY() || toZ != this.player.getZ(); // Paper - needed here as the difference in Y can be reset - also note: this is only a guess at whether collisions took place, floating point errors can make this true when it shouldn't be...
                             // Paper start - prevent position desync
-                            if (this.awaitingPositionFromClient != null) {
+                            if (this.awaitingPositionFromClient != null)
+                            {
                                 return; // ... thanks Mojang for letting move calls teleport across dimensions.
                             }
                             // Paper end - prevent position desync
@@ -1478,7 +1594,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                             d6 = d0 - this.player.getX();
                             d7 = d1 - this.player.getY();
-                            if (d7 > -0.5D || d7 < 0.5D) {
+                            if (d7 > -0.5D || d7 < 0.5D)
+                            {
                                 d7 = 0.0D;
                             }
 
@@ -1486,15 +1603,19 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             d10 = d6 * d6 + d7 * d7 + d8 * d8;
                             boolean movedWrongly = false; // Paper - Add fail move event; rename
 
-                            if (!this.player.isChangingDimension() && d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.gameMode.isCreative() && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR) { // Spigot
+                            if (!this.player.isChangingDimension() && d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.gameMode.isCreative() && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR)
+                            { // Spigot
                                 // Paper start - Add fail move event
                                 io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.MOVED_WRONGLY,
                                     toX, toY, toZ, toYaw, toPitch, true);
-                                if (!event.isAllowed()) {
+                                if (!event.isAllowed())
+                                {
                                     movedWrongly = true;
                                     if (event.getLogWarning())
-                                // Paper end
-                                ServerGamePacketListenerImpl.LOGGER.warn("{} moved wrongly!", this.player.getName().getString());
+                                    // Paper end
+                                    {
+                                        ServerGamePacketListenerImpl.LOGGER.warn("{} moved wrongly!", this.player.getName().getString());
+                                    }
                                 } // Paper
                             }
 
@@ -1502,32 +1623,40 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             // Paper start - optimise out extra getCubes
                             boolean teleportBack = !this.player.noPhysics && !this.player.isSleeping() && movedWrongly;
                             this.player.absMoveTo(d0, d1, d2, f, f1); // prevent desync by tping to the set position, dropped for unknown reasons by mojang
-                            if (!this.player.noPhysics && !this.player.isSleeping() && !teleportBack) {
+                            if (!this.player.noPhysics && !this.player.isSleeping() && !teleportBack)
+                            {
                                 AABB newBox = this.player.getBoundingBox();
-                                if (didCollide || !axisalignedbb.equals(newBox)) {
+                                if (didCollide || !axisalignedbb.equals(newBox))
+                                {
                                     // note: only call after setLocation, or else getBoundingBox is wrong
                                     teleportBack = this.hasNewCollision(worldserver, this.player, axisalignedbb, newBox);
                                 } // else: no collision at all detected, why do we care?
                             }
                             // Paper end - optimise out extra getCubes
-                            if (teleportBack) {
+                            if (teleportBack)
+                            {
                                 io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.CLIPPED_INTO_BLOCK,
                                     toX, toY, toZ, toYaw, toPitch, false);
-                                if (event.isAllowed()) {
+                                if (event.isAllowed())
+                                {
                                     teleportBack = false;
                                 }
                             }
-                            if (teleportBack) {
-                            // Paper end - Add fail move event
+                            if (teleportBack)
+                            {
+                                // Paper end - Add fail move event
                                 this.internalTeleport(d3, d4, d5, f, f1, Collections.emptySet()); // CraftBukkit - SPIGOT-1807: Don't call teleport event, when the client thinks the player is falling, because the chunks are not loaded on the client yet.
                                 this.player.doCheckFallDamage(this.player.getX() - d3, this.player.getY() - d4, this.player.getZ() - d5, packet.isOnGround());
-                            } else {
+                            }
+                            else
+                            {
                                 // CraftBukkit start - fire PlayerMoveEvent
                                 // Reset to old location first
                                 this.player.absMoveTo(prevX, prevY, prevZ, prevYaw, prevPitch);
 
                                 Player player = this.getCraftPlayer();
-                                if (!this.hasMoved) {
+                                if (!this.hasMoved)
+                                {
                                     this.lastPosX = prevX;
                                     this.lastPosY = prevY;
                                     this.lastPosZ = prevZ;
@@ -1539,14 +1668,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
 
                                 // If the packet contains movement information then we update the To location with the correct XYZ.
-                                if (packet.hasPos) {
+                                if (packet.hasPos)
+                                {
                                     to.setX(packet.x);
                                     to.setY(packet.y);
                                     to.setZ(packet.z);
                                 }
 
                                 // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
-                                if (packet.hasRot) {
+                                if (packet.hasRot)
+                                {
                                     to.setYaw(packet.yRot);
                                     to.setPitch(packet.xRot);
                                 }
@@ -1555,7 +1686,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
                                 float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
 
-                                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isImmobile()) {
+                                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isImmobile())
+                                {
                                     this.lastPosX = to.getX();
                                     this.lastPosY = to.getY();
                                     this.lastPosZ = to.getZ();
@@ -1567,7 +1699,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                     this.cserver.getPluginManager().callEvent(event);
 
                                     // If the event is cancelled we move the player back to their old location.
-                                    if (event.isCancelled()) {
+                                    if (event.isCancelled())
+                                    {
                                         this.teleport(from);
                                         return;
                                     }
@@ -1575,14 +1708,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                     // If a Plugin has changed the To destination then we teleport the Player
                                     // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
                                     // We only do this if the Event was not cancelled.
-                                    if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                                    if (!oldTo.equals(event.getTo()) && !event.isCancelled())
+                                    {
                                         this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.PLUGIN);
                                         return;
                                     }
 
                                     // Check to see if the Players Location has some how changed during the call of the event.
                                     // This can happen due to a plugin teleporting the player instead of using .setTo()
-                                    if (!from.equals(this.getCraftPlayer().getLocation()) && this.justTeleported) {
+                                    if (!from.equals(this.getCraftPlayer().getLocation()) && this.justTeleported)
+                                    {
                                         this.justTeleported = false;
                                         return;
                                     }
@@ -1595,11 +1730,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 this.player.serverLevel().getChunkSource().move(this.player);
                                 this.player.doCheckFallDamage(this.player.getX() - d3, this.player.getY() - d4, this.player.getZ() - d5, packet.isOnGround());
                                 this.player.setOnGroundWithKnownMovement(packet.isOnGround(), new Vec3(this.player.getX() - d3, this.player.getY() - d4, this.player.getZ() - d5));
-                                if (flag1) {
+                                if (flag1)
+                                {
                                     this.player.resetFallDistance();
                                 }
 
-                                if (packet.isOnGround() || this.player.isInLiquid() || this.player.onClimbable() || this.player.isSpectator() || flag || flag4) {
+                                if (packet.isOnGround() || this.player.isInLiquid() || this.player.onClimbable() || this.player.isSpectator() || flag || flag4)
+                                {
                                     this.player.resetCurrentImpulseContext();
                                 }
 
@@ -1616,7 +1753,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     // Paper start - optimise out extra getCubes
-    private boolean hasNewCollision(final ServerLevel world, final Entity entity, final AABB oldBox, final AABB newBox) {
+    private boolean hasNewCollision(final ServerLevel world, final Entity entity, final AABB oldBox, final AABB newBox)
+    {
         final List<AABB> collisionsBB = new java.util.ArrayList<>();
         final List<VoxelShape> collisionsVoxel = new java.util.ArrayList<>();
         io.papermc.paper.util.CollisionUtil.getCollisions(
@@ -1625,24 +1763,30 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             null, null
         );
 
-        for (int i = 0, len = collisionsBB.size(); i < len; ++i) {
+        for (int i = 0, len = collisionsBB.size(); i < len; ++i)
+        {
             final AABB box = collisionsBB.get(i);
-            if (!io.papermc.paper.util.CollisionUtil.voxelShapeIntersect(box, oldBox)) {
+            if (!io.papermc.paper.util.CollisionUtil.voxelShapeIntersect(box, oldBox))
+            {
                 return true;
             }
         }
 
-        for (int i = 0, len = collisionsVoxel.size(); i < len; ++i) {
+        for (int i = 0, len = collisionsVoxel.size(); i < len; ++i)
+        {
             final VoxelShape voxel = collisionsVoxel.get(i);
-            if (!io.papermc.paper.util.CollisionUtil.voxelShapeIntersectNoEmpty(voxel, oldBox)) {
+            if (!io.papermc.paper.util.CollisionUtil.voxelShapeIntersectNoEmpty(voxel, oldBox))
+            {
                 return true;
             }
         }
 
         return false;
     }
+
     // Paper end - optimise out extra getCubes
-    private boolean isPlayerCollidingWithAnythingNew(LevelReader world, AABB box, double newX, double newY, double newZ) {
+    private boolean isPlayerCollidingWithAnythingNew(LevelReader world, AABB box, double newX, double newY, double newZ)
+    {
         AABB axisalignedbb1 = this.player.getBoundingBox().move(newX - this.player.getX(), newY - this.player.getY(), newZ - this.player.getZ());
         Iterable<VoxelShape> iterable = world.getCollisions(this.player, axisalignedbb1.deflate(9.999999747378752E-6D));
         VoxelShape voxelshape = Shapes.create(box.deflate(9.999999747378752E-6D));
@@ -1650,31 +1794,38 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
         VoxelShape voxelshape1;
 
-        do {
-            if (!iterator.hasNext()) {
+        do
+        {
+            if (!iterator.hasNext())
+            {
                 return false;
             }
 
             voxelshape1 = (VoxelShape) iterator.next();
-        } while (Shapes.joinIsNotEmpty(voxelshape1, voxelshape, BooleanOp.AND));
+        }
+        while (Shapes.joinIsNotEmpty(voxelshape1, voxelshape, BooleanOp.AND));
 
         return true;
     }
 
     // CraftBukkit start - Delegate to teleport(Location)
-    public void teleport(double x, double y, double z, float yaw, float pitch) {
+    public void teleport(double x, double y, double z, float yaw, float pitch)
+    {
         this.teleport(x, y, z, yaw, pitch, PlayerTeleportEvent.TeleportCause.UNKNOWN);
     }
 
-    public void teleport(double d0, double d1, double d2, float f, float f1, PlayerTeleportEvent.TeleportCause cause) {
+    public void teleport(double d0, double d1, double d2, float f, float f1, PlayerTeleportEvent.TeleportCause cause)
+    {
         this.teleport(d0, d1, d2, f, f1, Collections.emptySet(), cause);
     }
 
-    public void teleport(double x, double y, double z, float yaw, float pitch, Set<RelativeMovement> flags) {
+    public void teleport(double x, double y, double z, float yaw, float pitch, Set<RelativeMovement> flags)
+    {
         this.teleport(x, y, z, yaw, pitch, flags, PlayerTeleportEvent.TeleportCause.UNKNOWN);
     }
 
-    public boolean teleport(double d0, double d1, double d2, float f, float f1, Set<RelativeMovement> set, PlayerTeleportEvent.TeleportCause cause) { // CraftBukkit - Return event status
+    public boolean teleport(double d0, double d1, double d2, float f, float f1, Set<RelativeMovement> set, PlayerTeleportEvent.TeleportCause cause)
+    { // CraftBukkit - Return event status
         Player player = this.getCraftPlayer();
         Location from = player.getLocation();
 
@@ -1686,21 +1837,24 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
         Location to = new Location(this.getCraftPlayer().getWorld(), x, y, z, yaw, pitch);
         // SPIGOT-5171: Triggered on join
-        if (from.equals(to)) {
+        if (from.equals(to))
+        {
             this.internalTeleport(d0, d1, d2, f, f1, set);
             return false; // CraftBukkit - Return event status
         }
 
         // Paper start - Teleport API
         Set<io.papermc.paper.entity.TeleportFlag.Relative> relativeFlags = java.util.EnumSet.noneOf(io.papermc.paper.entity.TeleportFlag.Relative.class);
-        for (RelativeMovement relativeArgument : set) {
+        for (RelativeMovement relativeArgument : set)
+        {
             relativeFlags.add(org.bukkit.craftbukkit.entity.CraftPlayer.toApiRelativeFlag(relativeArgument));
         }
         PlayerTeleportEvent event = new PlayerTeleportEvent(player, from.clone(), to.clone(), cause, java.util.Set.copyOf(relativeFlags));
         // Paper end - Teleport API
         this.cserver.getPluginManager().callEvent(event);
 
-        if (event.isCancelled() || !to.equals(event.getTo())) {
+        if (event.isCancelled() || !to.equals(event.getTo()))
+        {
             // set.clear(); // Can't relative teleport // Paper - Teleport API; Now you can!
             to = event.isCancelled() ? event.getFrom() : event.getTo();
             d0 = to.getX();
@@ -1714,24 +1868,32 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         return event.isCancelled(); // CraftBukkit - Return event status
     }
 
-    public void teleport(Location dest) {
+    public void teleport(Location dest)
+    {
         this.internalTeleport(dest.getX(), dest.getY(), dest.getZ(), dest.getYaw(), dest.getPitch(), Collections.emptySet());
     }
 
-    public void internalTeleport(double d0, double d1, double d2, float f, float f1, Set<RelativeMovement> set) { // Paper
+    public void internalTeleport(double d0, double d1, double d2, float f, float f1, Set<RelativeMovement> set)
+    { // Paper
         org.spigotmc.AsyncCatcher.catchOp("teleport"); // Paper
         // Paper start - Prevent teleporting dead entities
-        if (player.isRemoved()) {
+        if (player.isRemoved())
+        {
             LOGGER.info("Attempt to teleport removed player {} restricted", player.getScoreboardName());
-            if (server.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Attempt to teleport removed player");
+            if (server.isDebugging())
+            {
+                io.papermc.paper.util.TraceUtil.dumpTraceForThread("Attempt to teleport removed player");
+            }
             return;
         }
         // Paper end - Prevent teleporting dead entities
         // CraftBukkit start
-        if (Float.isNaN(f)) {
+        if (Float.isNaN(f))
+        {
             f = 0;
         }
-        if (Float.isNaN(f1)) {
+        if (Float.isNaN(f1))
+        {
             f1 = 0;
         }
 
@@ -1744,7 +1906,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         float f3 = set.contains(RelativeMovement.X_ROT) ? this.player.getXRot() : 0.0F;
 
         this.awaitingPositionFromClient = new Vec3(d0, d1, d2);
-        if (++this.awaitingTeleport == Integer.MAX_VALUE) {
+        if (++this.awaitingTeleport == Integer.MAX_VALUE)
+        {
             this.awaitingTeleport = 0;
         }
 
@@ -1763,17 +1926,23 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handlePlayerAction(ServerboundPlayerActionPacket packet) {
+    public void handlePlayerAction(ServerboundPlayerActionPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
         BlockPos blockposition = packet.getPos();
 
         this.player.resetLastActionTime();
         ServerboundPlayerActionPacket.Action packetplayinblockdig_enumplayerdigtype = packet.getAction();
 
-        switch (packetplayinblockdig_enumplayerdigtype) {
+        switch (packetplayinblockdig_enumplayerdigtype)
+        {
             case SWAP_ITEM_WITH_OFFHAND:
-                if (!this.player.isSpectator()) {
+                if (!this.player.isSpectator())
+                {
                     ItemStack itemstack = this.player.getItemInHand(InteractionHand.OFF_HAND);
 
                     // CraftBukkit start - inspiration taken from DispenserRegistry (See SpigotCraft#394)
@@ -1781,17 +1950,24 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                     CraftItemStack offHand = CraftItemStack.asCraftMirror(this.player.getItemInHand(InteractionHand.MAIN_HAND));
                     PlayerSwapHandItemsEvent swapItemsEvent = new PlayerSwapHandItemsEvent(this.getCraftPlayer(), mainHand.clone(), offHand.clone());
                     this.cserver.getPluginManager().callEvent(swapItemsEvent);
-                    if (swapItemsEvent.isCancelled()) {
+                    if (swapItemsEvent.isCancelled())
+                    {
                         return;
                     }
-                    if (swapItemsEvent.getOffHandItem().equals(offHand)) {
+                    if (swapItemsEvent.getOffHandItem().equals(offHand))
+                    {
                         this.player.setItemInHand(InteractionHand.OFF_HAND, this.player.getItemInHand(InteractionHand.MAIN_HAND));
-                    } else {
+                    }
+                    else
+                    {
                         this.player.setItemInHand(InteractionHand.OFF_HAND, CraftItemStack.asNMSCopy(swapItemsEvent.getOffHandItem()));
                     }
-                    if (swapItemsEvent.getMainHandItem().equals(mainHand)) {
+                    if (swapItemsEvent.getMainHandItem().equals(mainHand))
+                    {
                         this.player.setItemInHand(InteractionHand.MAIN_HAND, itemstack);
-                    } else {
+                    }
+                    else
+                    {
                         this.player.setItemInHand(InteractionHand.MAIN_HAND, CraftItemStack.asNMSCopy(swapItemsEvent.getMainHandItem()));
                     }
                     // CraftBukkit end
@@ -1800,16 +1976,21 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 return;
             case DROP_ITEM:
-                if (!this.player.isSpectator()) {
+                if (!this.player.isSpectator())
+                {
                     // limit how quickly items can be dropped
                     // If the ticks aren't the same then the count starts from 0 and we update the lastDropTick.
-                    if (this.lastDropTick != MinecraftServer.currentTick) {
+                    if (this.lastDropTick != MinecraftServer.currentTick)
+                    {
                         this.dropCount = 0;
                         this.lastDropTick = MinecraftServer.currentTick;
-                    } else {
+                    }
+                    else
+                    {
                         // Else we increment the drop count and check the amount.
                         this.dropCount++;
-                        if (this.dropCount >= 20) {
+                        if (this.dropCount >= 20)
+                        {
                             ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " dropped their items too quickly!");
                             this.disconnect("You dropped your items too quickly (Hacking?)", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause
                             return;
@@ -1821,7 +2002,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 return;
             case DROP_ALL_ITEMS:
-                if (!this.player.isSpectator()) {
+                if (!this.player.isSpectator())
+                {
                     this.player.drop(true);
                 }
 
@@ -1833,7 +2015,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             case ABORT_DESTROY_BLOCK:
             case STOP_DESTROY_BLOCK:
                 // Paper start - Don't allow digging into unloaded chunks
-                if (this.player.level().getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4) == null) {
+                if (this.player.level().getChunkIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4) == null)
+                {
                     this.player.connection.ackBlockChangesUpTo(packet.getSequence());
                     return;
                 }
@@ -1848,14 +2031,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 this.player.gameMode.captureSentBlockEntities = false;
                 // If a block entity was modified speedup the block change ack to avoid the block entity
                 // being overriden.
-                if (this.player.gameMode.capturedBlockEntity) {
+                if (this.player.gameMode.capturedBlockEntity)
+                {
                     // manually tick
                     this.send(new ClientboundBlockChangedAckPacket(this.ackBlockChangesUpTo));
                     this.player.connection.ackBlockChangesUpTo = -1;
 
                     this.player.gameMode.capturedBlockEntity = false;
                     BlockEntity tileentity = this.player.level().getBlockEntity(blockposition);
-                    if (tileentity != null) {
+                    if (tileentity != null)
+                    {
                         this.player.connection.send(tileentity.getUpdatePacket());
                     }
                 }
@@ -1866,10 +2051,14 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    private static boolean wasBlockPlacementAttempt(ServerPlayer player, ItemStack stack) {
-        if (stack.isEmpty()) {
+    private static boolean wasBlockPlacementAttempt(ServerPlayer player, ItemStack stack)
+    {
+        if (stack.isEmpty())
+        {
             return false;
-        } else {
+        }
+        else
+        {
             Item item = stack.getItem();
 
             return (item instanceof BlockItem || item instanceof BucketItem) && !player.getCooldowns().isOnCooldown(item);
@@ -1879,14 +2068,21 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // Spigot start - limit place/interactions
     private int limitedPackets;
     private long lastLimitedPacket = -1;
-    private static int getSpamThreshold() { return io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.incomingPacketThreshold; } // Paper - Configurable threshold
 
-    private boolean checkLimit(long timestamp) {
-        if (this.lastLimitedPacket != -1 && timestamp - this.lastLimitedPacket < getSpamThreshold() && this.limitedPackets++ >= 8) { // Paper - Configurable threshold; raise packet limit to 8
+    private static int getSpamThreshold()
+    {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.incomingPacketThreshold;
+    } // Paper - Configurable threshold
+
+    private boolean checkLimit(long timestamp)
+    {
+        if (this.lastLimitedPacket != -1 && timestamp - this.lastLimitedPacket < getSpamThreshold() && this.limitedPackets++ >= 8)
+        { // Paper - Configurable threshold; raise packet limit to 8
             return false;
         }
 
-        if (this.lastLimitedPacket == -1 || timestamp - this.lastLimitedPacket >= getSpamThreshold()) { // Paper - Configurable threshold
+        if (this.lastLimitedPacket == -1 || timestamp - this.lastLimitedPacket >= getSpamThreshold())
+        { // Paper - Configurable threshold
             this.lastLimitedPacket = timestamp;
             this.limitedPackets = 0;
             return true;
@@ -1897,52 +2093,71 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // Spigot end
 
     @Override
-    public void handleUseItemOn(ServerboundUseItemOnPacket packet) {
+    public void handleUseItemOn(ServerboundUseItemOnPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
-        if (!this.checkLimit(packet.timestamp)) return; // Spigot - check limit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
+        if (!this.checkLimit(packet.timestamp))
+        {
+            return; // Spigot - check limit
+        }
         this.player.connection.ackBlockChangesUpTo(packet.getSequence());
         ServerLevel worldserver = this.player.serverLevel();
         InteractionHand enumhand = packet.getHand();
         ItemStack itemstack = this.player.getItemInHand(enumhand);
 
-        if (itemstack.isItemEnabled(worldserver.enabledFeatures())) {
+        if (itemstack.isItemEnabled(worldserver.enabledFeatures()))
+        {
             BlockHitResult movingobjectpositionblock = packet.getHitResult();
             Vec3 vec3d = movingobjectpositionblock.getLocation();
             // Paper start - improve distance check
-            if (!Double.isFinite(vec3d.x) || !Double.isFinite(vec3d.y) || !Double.isFinite(vec3d.z)) {
+            if (!Double.isFinite(vec3d.x) || !Double.isFinite(vec3d.y) || !Double.isFinite(vec3d.z))
+            {
                 return;
             }
             // Paper end - improve distance check
             BlockPos blockposition = movingobjectpositionblock.getBlockPos();
 
-            if (this.player.canInteractWithBlock(blockposition, 1.0D)) {
+            if (this.player.canInteractWithBlock(blockposition, 1.0D))
+            {
                 Vec3 vec3d1 = vec3d.subtract(Vec3.atCenterOf(blockposition));
                 double d0 = 1.0000001D;
 
-                if (Math.abs(vec3d1.x()) < 1.0000001D && Math.abs(vec3d1.y()) < 1.0000001D && Math.abs(vec3d1.z()) < 1.0000001D) {
+                if (Math.abs(vec3d1.x()) < 1.0000001D && Math.abs(vec3d1.y()) < 1.0000001D && Math.abs(vec3d1.z()) < 1.0000001D)
+                {
                     Direction enumdirection = movingobjectpositionblock.getDirection();
 
                     this.player.resetLastActionTime();
                     int i = this.player.level().getMaxBuildHeight();
 
-                    if (blockposition.getY() < i) {
-                        if (this.awaitingPositionFromClient == null && (worldserver.mayInteract(this.player, blockposition) || (worldserver.paperConfig().spawn.allowUsingSignsInsideSpawnProtection && worldserver.getBlockState(blockposition).getBlock() instanceof net.minecraft.world.level.block.SignBlock))) { // Paper - Allow using signs inside spawn protection
+                    if (blockposition.getY() < i)
+                    {
+                        if (this.awaitingPositionFromClient == null && (worldserver.mayInteract(this.player, blockposition) || (worldserver.paperConfig().spawn.allowUsingSignsInsideSpawnProtection && worldserver.getBlockState(blockposition).getBlock() instanceof net.minecraft.world.level.block.SignBlock)))
+                        { // Paper - Allow using signs inside spawn protection
                             InteractionResult enuminteractionresult = this.player.gameMode.useItemOn(this.player, worldserver, itemstack, enumhand, movingobjectpositionblock);
 
-                            if (enuminteractionresult.consumesAction()) {
+                            if (enuminteractionresult.consumesAction())
+                            {
                                 CriteriaTriggers.ANY_BLOCK_USE.trigger(this.player, movingobjectpositionblock.getBlockPos(), itemstack.copy());
                             }
 
-                            if (enumdirection == Direction.UP && !enuminteractionresult.consumesAction() && blockposition.getY() >= i - 1 && ServerGamePacketListenerImpl.wasBlockPlacementAttempt(this.player, itemstack)) {
+                            if (enumdirection == Direction.UP && !enuminteractionresult.consumesAction() && blockposition.getY() >= i - 1 && ServerGamePacketListenerImpl.wasBlockPlacementAttempt(this.player, itemstack))
+                            {
                                 MutableComponent ichatmutablecomponent = Component.translatable("build.tooHigh", i - 1).withStyle(ChatFormatting.RED);
 
                                 this.player.sendSystemMessage(ichatmutablecomponent, true);
-                            } else if (enuminteractionresult.shouldSwing() && !this.player.gameMode.interactResult) { // Paper - Call interact event
+                            }
+                            else if (enuminteractionresult.shouldSwing() && !this.player.gameMode.interactResult)
+                            { // Paper - Call interact event
                                 this.player.swing(enumhand, true);
                             }
                         }
-                    } else {
+                    }
+                    else
+                    {
                         MutableComponent ichatmutablecomponent1 = Component.translatable("build.tooHigh", i - 1).withStyle(ChatFormatting.RED);
 
                         this.player.sendSystemMessage(ichatmutablecomponent1, true);
@@ -1950,7 +2165,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                     this.player.connection.send(new ClientboundBlockUpdatePacket(worldserver, blockposition));
                     this.player.connection.send(new ClientboundBlockUpdatePacket(worldserver, blockposition.relative(enumdirection)));
-                } else {
+                }
+                else
+                {
                     ServerGamePacketListenerImpl.LOGGER.warn("Rejecting UseItemOnPacket from {}: Location {} too far away from hit block {}.", new Object[]{this.player.getGameProfile().getName(), vec3d, blockposition});
                 }
             }
@@ -1958,17 +2175,25 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleUseItem(ServerboundUseItemPacket packet) {
+    public void handleUseItem(ServerboundUseItemPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
-        if (!this.checkLimit(packet.timestamp)) return; // Spigot - check limit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
+        if (!this.checkLimit(packet.timestamp))
+        {
+            return; // Spigot - check limit
+        }
         this.ackBlockChangesUpTo(packet.getSequence());
         ServerLevel worldserver = this.player.serverLevel();
         InteractionHand enumhand = packet.getHand();
         ItemStack itemstack = this.player.getItemInHand(enumhand);
 
         this.player.resetLastActionTime();
-        if (!itemstack.isEmpty() && itemstack.isItemEnabled(worldserver.enabledFeatures())) {
+        if (!itemstack.isEmpty() && itemstack.isItemEnabled(worldserver.enabledFeatures()))
+        {
             // CraftBukkit start
             // Raytrace to look for 'rogue armswings'
             float f1 = this.player.getXRot();
@@ -1984,38 +2209,47 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             float f6 = Mth.sin(-f1 * 0.017453292F);
             float f7 = f4 * f5;
             float f8 = f3 * f5;
-            double d3 = this.player.gameMode.getGameModeForPlayer()== GameType.CREATIVE ? 5.0D : 4.5D;
+            double d3 = this.player.gameMode.getGameModeForPlayer() == GameType.CREATIVE ? 5.0D : 4.5D;
             Vec3 vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
             HitResult movingobjectposition = this.player.level().clip(new ClipContext(vec3d, vec3d1, ClipContext.Block.OUTLINE, ClipContext.Fluid.NONE, this.player));
 
             boolean cancelled;
-            if (movingobjectposition == null || movingobjectposition.getType() != HitResult.Type.BLOCK) {
+            if (movingobjectposition == null || movingobjectposition.getType() != HitResult.Type.BLOCK)
+            {
                 org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_AIR, itemstack, enumhand);
                 cancelled = event.useItemInHand() == Event.Result.DENY;
-            } else {
+            }
+            else
+            {
                 BlockHitResult movingobjectpositionblock = (BlockHitResult) movingobjectposition;
-                if (this.player.gameMode.firedInteract && this.player.gameMode.interactPosition.equals(movingobjectpositionblock.getBlockPos()) && this.player.gameMode.interactHand == enumhand && ItemStack.isSameItemSameComponents(this.player.gameMode.interactItemStack, itemstack)) {
+                if (this.player.gameMode.firedInteract && this.player.gameMode.interactPosition.equals(movingobjectpositionblock.getBlockPos()) && this.player.gameMode.interactHand == enumhand && ItemStack.isSameItemSameComponents(this.player.gameMode.interactItemStack, itemstack))
+                {
                     cancelled = this.player.gameMode.interactResult;
-                } else {
+                }
+                else
+                {
                     org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_BLOCK, movingobjectpositionblock.getBlockPos(), movingobjectpositionblock.getDirection(), itemstack, true, enumhand, movingobjectpositionblock.getLocation());
                     cancelled = event.useItemInHand() == Event.Result.DENY;
                 }
                 this.player.gameMode.firedInteract = false;
             }
 
-            if (cancelled) {
+            if (cancelled)
+            {
                 this.player.resyncUsingItem(this.player); // Paper - Properly cancel usable items
                 this.player.getBukkitEntity().updateInventory(); // SPIGOT-2524
                 return;
             }
             itemstack = this.player.getItemInHand(enumhand); // Update in case it was changed in the event
-            if (itemstack.isEmpty()) {
+            if (itemstack.isEmpty())
+            {
                 return;
             }
             // CraftBukkit end
             InteractionResult enuminteractionresult = this.player.gameMode.useItem(this.player, worldserver, itemstack, enumhand);
 
-            if (enuminteractionresult.shouldSwing()) {
+            if (enuminteractionresult.shouldSwing())
+            {
                 this.player.swing(enumhand, true);
             }
 
@@ -2023,16 +2257,27 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleTeleportToEntityPacket(ServerboundTeleportToEntityPacket packet) {
+    public void handleTeleportToEntityPacket(ServerboundTeleportToEntityPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isSpectator()) {
+        if (this.player.isSpectator())
+        {
             Iterator iterator = this.server.getAllLevels().iterator();
 
-            while (iterator.hasNext()) {
+            while (iterator.hasNext())
+            {
                 ServerLevel worldserver = (ServerLevel) iterator.next();
                 Entity entity = packet.getEntity(worldserver);
 
-                if (entity != null) {
+                if (entity != null)
+                {
+                    // Scissors start - Add spectator teleport event
+                    final SpectatorTeleportEvent event = new SpectatorTeleportEvent(this.player.getBukkitEntity(), entity.getBukkitEntity());
+                    if (!event.callEvent())
+                    {
+                        return;
+                    }
+                    // Scissors end
                     this.player.teleportTo(worldserver, entity.getX(), entity.getY(), entity.getZ(), entity.getYRot(), entity.getXRot(), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.SPECTATE); // CraftBukkit
                     return;
                 }
@@ -2042,28 +2287,36 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handlePaddleBoat(ServerboundPaddleBoatPacket packet) {
+    public void handlePaddleBoat(ServerboundPaddleBoatPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         Entity entity = this.player.getControlledVehicle();
 
-        if (entity instanceof Boat entityboat) {
+        if (entity instanceof Boat entityboat)
+        {
             entityboat.setPaddleState(packet.getLeft(), packet.getRight());
         }
 
     }
 
     @Override
-    public void onDisconnect(Component reason) {
+    public void onDisconnect(Component reason)
+    {
         // Paper start - Fix kick event leave message not being sent
         this.onDisconnect(reason, null);
     }
+
     @Override
-    public void onDisconnect(Component reason, @Nullable net.kyori.adventure.text.Component quitMessage) {
+    public void onDisconnect(Component reason, @Nullable net.kyori.adventure.text.Component quitMessage)
+    {
         // Paper end - Fix kick event leave message not being sent
         // CraftBukkit start - Rarely it would send a disconnect line twice
-        if (this.processedDisconnect) {
+        if (this.processedDisconnect)
+        {
             return;
-        } else {
+        }
+        else
+        {
             this.processedDisconnect = true;
         }
         // CraftBukkit end
@@ -2073,11 +2326,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     // Paper start - Fix kick event leave message not being sent
-    private void removePlayerFromWorld() {
+    private void removePlayerFromWorld()
+    {
         this.removePlayerFromWorld(null);
     }
 
-    private void removePlayerFromWorld(@Nullable net.kyori.adventure.text.Component quitMessage) {
+    private void removePlayerFromWorld(@Nullable net.kyori.adventure.text.Component quitMessage)
+    {
         // Paper end - Fix kick event leave message not being sent
         this.chatMessageChain.close();
         // CraftBukkit start - Replace vanilla quit message handling with our own.
@@ -2089,7 +2344,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         this.player.disconnect();
         // Paper start - Adventure
         quitMessage = quitMessage == null ? this.server.getPlayerList().remove(this.player) : this.server.getPlayerList().remove(this.player, quitMessage); // Paper - pass in quitMessage to fix kick message not being used
-        if ((quitMessage != null) && !quitMessage.equals(net.kyori.adventure.text.Component.empty())) {
+        if ((quitMessage != null) && !quitMessage.equals(net.kyori.adventure.text.Component.empty()))
+        {
             this.server.getPlayerList().broadcastSystemMessage(PaperAdventure.asVanilla(quitMessage), false);
             // Paper end
         }
@@ -2097,58 +2353,81 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         this.player.getTextFilter().leave();
     }
 
-    public void ackBlockChangesUpTo(int sequence) {
-        if (sequence < 0) {
+    public void ackBlockChangesUpTo(int sequence)
+    {
+        if (sequence < 0)
+        {
             this.disconnect("Expected packet sequence nr >= 0", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - Treat sequence violations like they should be
             throw new IllegalArgumentException("Expected packet sequence nr >= 0");
-        } else {
+        }
+        else
+        {
             this.ackBlockChangesUpTo = Math.max(sequence, this.ackBlockChangesUpTo);
         }
     }
 
     @Override
-    public void handleSetCarriedItem(ServerboundSetCarriedItemPacket packet) {
+    public void handleSetCarriedItem(ServerboundSetCarriedItemPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
-        if (packet.getSlot() >= 0 && packet.getSlot() < Inventory.getSelectionSize()) {
-            if (packet.getSlot() == this.player.getInventory().selected) { return; } // Paper - don't fire itemheldevent when there wasn't a slot change
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
+        if (packet.getSlot() >= 0 && packet.getSlot() < Inventory.getSelectionSize())
+        {
+            if (packet.getSlot() == this.player.getInventory().selected)
+            {
+                return;
+            } // Paper - don't fire itemheldevent when there wasn't a slot change
             PlayerItemHeldEvent event = new PlayerItemHeldEvent(this.getCraftPlayer(), this.player.getInventory().selected, packet.getSlot());
             this.cserver.getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
+            if (event.isCancelled())
+            {
                 this.send(new ClientboundSetCarriedItemPacket(this.player.getInventory().selected));
                 this.player.resetLastActionTime();
                 return;
             }
             // CraftBukkit end
-            if (this.player.getInventory().selected != packet.getSlot() && this.player.getUsedItemHand() == InteractionHand.MAIN_HAND) {
+            if (this.player.getInventory().selected != packet.getSlot() && this.player.getUsedItemHand() == InteractionHand.MAIN_HAND)
+            {
                 this.player.stopUsingItem();
             }
 
             this.player.getInventory().selected = packet.getSlot();
             this.player.resetLastActionTime();
-        } else {
+        }
+        else
+        {
             ServerGamePacketListenerImpl.LOGGER.warn("{} tried to set an invalid carried item", this.player.getName().getString());
             this.disconnect("Invalid hotbar selection (Hacking?)", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // CraftBukkit // Paper - kick event cause
         }
     }
 
     @Override
-    public void handleChat(ServerboundChatPacket packet) {
+    public void handleChat(ServerboundChatPacket packet)
+    {
         // CraftBukkit start - async chat
         // SPIGOT-3638
-        if (this.server.isStopped()) {
+        if (this.server.isStopped())
+        {
             return;
         }
         // CraftBukkit end
         Optional<LastSeenMessages> optional = this.unpackAndApplyLastSeen(packet.lastSeenMessages());
 
-        if (!optional.isEmpty()) {
-            this.tryHandleChat(packet.message(), () -> {
+        if (!optional.isEmpty())
+        {
+            this.tryHandleChat(packet.message(), () ->
+            {
                 PlayerChatMessage playerchatmessage;
 
-                try {
+                try
+                {
                     playerchatmessage = this.getSignedMessage(packet, (LastSeenMessages) optional.get());
-                } catch (SignedMessageChain.DecodeException signedmessagechain_a) {
+                }
+                catch (SignedMessageChain.DecodeException signedmessagechain_a)
+                {
                     this.handleMessageDecodeFailure(signedmessagechain_a);
                     return;
                 }
@@ -2156,7 +2435,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 CompletableFuture<FilteredText> completablefuture = this.filterTextPacket(playerchatmessage.signedContent()).thenApplyAsync(Function.identity(), this.server.chatExecutor); // CraftBukkit - async chat
                 CompletableFuture<Component> componentFuture = this.server.getChatDecorator().decorate(this.player, null, playerchatmessage.decoratedContent()); // Paper - Adventure
 
-                this.chatMessageChain.append(CompletableFuture.allOf(completablefuture, componentFuture), (filteredtext) -> { // Paper - Adventure
+                this.chatMessageChain.append(CompletableFuture.allOf(completablefuture, componentFuture), (filteredtext) ->
+                { // Paper - Adventure
                     PlayerChatMessage playerchatmessage1 = playerchatmessage.withUnsignedContent(componentFuture.join()).filter(completablefuture.join().mask()); // Paper - Adventure
 
                     this.broadcastChatMessage(playerchatmessage1);
@@ -2166,10 +2446,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleChatCommand(ServerboundChatCommandPacket packet) {
-        this.tryHandleChat(packet.command(), () -> {
+    public void handleChatCommand(ServerboundChatCommandPacket packet)
+    {
+        this.tryHandleChat(packet.command(), () ->
+        {
             // CraftBukkit start - SPIGOT-7346: Prevent disconnected players from executing commands
-            if (this.player.hasDisconnected()) {
+            if (this.player.hasDisconnected())
+            {
                 return;
             }
             // CraftBukkit end
@@ -2178,39 +2461,49 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }, true); // CraftBukkit - sync commands
     }
 
-    private void performUnsignedChatCommand(String command) {
+    private void performUnsignedChatCommand(String command)
+    {
         // CraftBukkit start
         String command1 = "/" + command;
-        if (org.spigotmc.SpigotConfig.logCommands) { // Paper - Add missing SpigotConfig logCommands check
-        ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command1);
+        if (org.spigotmc.SpigotConfig.logCommands)
+        { // Paper - Add missing SpigotConfig logCommands check
+            ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command1);
         }
 
         PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(this.getCraftPlayer(), command1, new LazyPlayerSet(this.server));
         this.cserver.getPluginManager().callEvent(event);
 
-        if (event.isCancelled()) {
+        if (event.isCancelled())
+        {
             return;
         }
         command = event.getMessage().substring(1);
         // CraftBukkit end
         ParseResults<CommandSourceStack> parseresults = this.parseCommand(command);
 
-        if (this.server.enforceSecureProfile() && SignableCommand.hasSignableArguments(parseresults)) {
+        if (this.server.enforceSecureProfile() && SignableCommand.hasSignableArguments(parseresults))
+        {
             ServerGamePacketListenerImpl.LOGGER.error("Received unsigned command packet from {}, but the command requires signable arguments: {}", this.player.getGameProfile().getName(), command);
             this.player.sendSystemMessage(ServerGamePacketListenerImpl.INVALID_COMMAND_SIGNATURE);
-        } else {
+        }
+        else
+        {
             this.server.getCommands().performCommand(parseresults, command);
         }
     }
 
     @Override
-    public void handleSignedChatCommand(ServerboundChatCommandSignedPacket packet) {
+    public void handleSignedChatCommand(ServerboundChatCommandSignedPacket packet)
+    {
         Optional<LastSeenMessages> optional = this.unpackAndApplyLastSeen(packet.lastSeenMessages());
 
-        if (!optional.isEmpty()) {
-            this.tryHandleChat(packet.command(), () -> {
+        if (!optional.isEmpty())
+        {
+            this.tryHandleChat(packet.command(), () ->
+            {
                 // CraftBukkit start - SPIGOT-7346: Prevent disconnected players from executing commands
-                if (this.player.hasDisconnected()) {
+                if (this.player.hasDisconnected())
+                {
                     return;
                 }
                 // CraftBukkit end
@@ -2220,17 +2513,20 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    private void performSignedChatCommand(ServerboundChatCommandSignedPacket packet, LastSeenMessages lastSeenMessages) {
+    private void performSignedChatCommand(ServerboundChatCommandSignedPacket packet, LastSeenMessages lastSeenMessages)
+    {
         // CraftBukkit start
         String command = "/" + packet.command();
-        if (org.spigotmc.SpigotConfig.logCommands) { // Paper - Add missing SpigotConfig logCommands check
-        ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command);
+        if (org.spigotmc.SpigotConfig.logCommands)
+        { // Paper - Add missing SpigotConfig logCommands check
+            ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command);
         } // Paper - Add missing SpigotConfig logCommands check
 
         PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(this.getCraftPlayer(), command, new LazyPlayerSet(this.server));
         this.cserver.getPluginManager().callEvent(event);
 
-        if (event.isCancelled()) {
+        if (event.isCancelled())
+        {
             return;
         }
         command = event.getMessage().substring(1);
@@ -2240,41 +2536,52 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
         Map map;
 
-        try {
+        try
+        {
             map = (packet.command().equals(command)) ? this.collectSignedArguments(packet, SignableCommand.of(parseresults), lastSeenMessages) : Collections.emptyMap(); // CraftBukkit
-        } catch (SignedMessageChain.DecodeException signedmessagechain_a) {
+        }
+        catch (SignedMessageChain.DecodeException signedmessagechain_a)
+        {
             this.handleMessageDecodeFailure(signedmessagechain_a);
             return;
         }
 
         CommandSigningContext.SignedArguments commandsigningcontext_a = new CommandSigningContext.SignedArguments(map);
 
-        parseresults = Commands.<CommandSourceStack>mapSource(parseresults, (commandlistenerwrapper) -> { // CraftBukkit - decompile error
+        parseresults = Commands.<CommandSourceStack>mapSource(parseresults, (commandlistenerwrapper) ->
+        { // CraftBukkit - decompile error
             return commandlistenerwrapper.withSigningContext(commandsigningcontext_a, this.chatMessageChain);
         });
         this.server.getCommands().performCommand(parseresults, command); // CraftBukkit
     }
 
-    private void handleMessageDecodeFailure(SignedMessageChain.DecodeException exception) {
+    private void handleMessageDecodeFailure(SignedMessageChain.DecodeException exception)
+    {
         ServerGamePacketListenerImpl.LOGGER.warn("Failed to update secure chat state for {}: '{}'", this.player.getGameProfile().getName(), exception.getComponent().getString());
         this.player.sendSystemMessage(exception.getComponent().copy().withStyle(ChatFormatting.RED));
     }
 
-    private <S> Map<String, PlayerChatMessage> collectSignedArguments(ServerboundChatCommandSignedPacket packet, SignableCommand<S> arguments, LastSeenMessages lastSeenMessages) throws SignedMessageChain.DecodeException {
+    private <S> Map<String, PlayerChatMessage> collectSignedArguments(ServerboundChatCommandSignedPacket packet, SignableCommand<S> arguments, LastSeenMessages lastSeenMessages) throws SignedMessageChain.DecodeException
+    {
         List<ArgumentSignatures.Entry> list = packet.argumentSignatures().entries();
         List<SignableCommand.Argument<S>> list1 = arguments.arguments();
 
-        if (list.isEmpty()) {
+        if (list.isEmpty())
+        {
             return this.collectUnsignedArguments(list1);
-        } else {
+        }
+        else
+        {
             Map<String, PlayerChatMessage> map = new Object2ObjectOpenHashMap();
             Iterator iterator = list.iterator();
 
-            while (iterator.hasNext()) {
+            while (iterator.hasNext())
+            {
                 ArgumentSignatures.Entry argumentsignatures_a = (ArgumentSignatures.Entry) iterator.next();
                 SignableCommand.Argument<S> signablecommand_a = arguments.getArgument(argumentsignatures_a.name());
 
-                if (signablecommand_a == null) {
+                if (signablecommand_a == null)
+                {
                     this.signedMessageDecoder.setChainBroken();
                     throw ServerGamePacketListenerImpl.createSignedArgumentMismatchException(packet.command(), list, list1);
                 }
@@ -2288,23 +2595,28 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
             SignableCommand.Argument signablecommand_a1;
 
-            do {
-                if (!iterator.hasNext()) {
+            do
+            {
+                if (!iterator.hasNext())
+                {
                     return map;
                 }
 
                 signablecommand_a1 = (SignableCommand.Argument) iterator.next();
-            } while (map.containsKey(signablecommand_a1.name()));
+            }
+            while (map.containsKey(signablecommand_a1.name()));
 
             throw ServerGamePacketListenerImpl.createSignedArgumentMismatchException(packet.command(), list, list1);
         }
     }
 
-    private <S> Map<String, PlayerChatMessage> collectUnsignedArguments(List<SignableCommand.Argument<S>> arguments) throws SignedMessageChain.DecodeException {
+    private <S> Map<String, PlayerChatMessage> collectUnsignedArguments(List<SignableCommand.Argument<S>> arguments) throws SignedMessageChain.DecodeException
+    {
         Map<String, PlayerChatMessage> map = new HashMap();
         Iterator iterator = arguments.iterator();
 
-        while (iterator.hasNext()) {
+        while (iterator.hasNext())
+        {
             SignableCommand.Argument<S> signablecommand_a = (SignableCommand.Argument) iterator.next();
             SignedMessageBody signedmessagebody = SignedMessageBody.unsigned(signablecommand_a.value());
 
@@ -2314,7 +2626,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         return map;
     }
 
-    private static <S> SignedMessageChain.DecodeException createSignedArgumentMismatchException(String command, List<ArgumentSignatures.Entry> actual, List<SignableCommand.Argument<S>> expected) {
+    private static <S> SignedMessageChain.DecodeException createSignedArgumentMismatchException(String command, List<ArgumentSignatures.Entry> actual, List<SignableCommand.Argument<S>> expected)
+    {
         String s1 = (String) actual.stream().map(ArgumentSignatures.Entry::name).collect(Collectors.joining(", "));
         String s2 = (String) expected.stream().map(SignableCommand.Argument::name).collect(Collectors.joining(", "));
 
@@ -2322,36 +2635,49 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         return new SignedMessageChain.DecodeException(ServerGamePacketListenerImpl.INVALID_COMMAND_SIGNATURE);
     }
 
-    private ParseResults<CommandSourceStack> parseCommand(String command) {
+    private ParseResults<CommandSourceStack> parseCommand(String command)
+    {
         com.mojang.brigadier.CommandDispatcher<CommandSourceStack> com_mojang_brigadier_commanddispatcher = this.server.getCommands().getDispatcher();
 
         return com_mojang_brigadier_commanddispatcher.parse(command, this.player.createCommandSourceStack());
     }
 
-    private void tryHandleChat(String s, Runnable runnable, boolean sync) { // CraftBukkit
-        if (ServerGamePacketListenerImpl.isChatMessageIllegal(s)) {
+    private void tryHandleChat(String s, Runnable runnable, boolean sync)
+    { // CraftBukkit
+        if (ServerGamePacketListenerImpl.isChatMessageIllegal(s))
+        {
             this.disconnect(Component.translatable("multiplayer.disconnect.illegal_characters"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_CHARACTERS); // Paper
-        } else if (this.player.isRemoved() || this.player.getChatVisibility() == ChatVisiblity.HIDDEN) { // CraftBukkit - dead men tell no tales
+        }
+        else if (this.player.isRemoved() || this.player.getChatVisibility() == ChatVisiblity.HIDDEN)
+        { // CraftBukkit - dead men tell no tales
             this.send(new ClientboundSystemChatPacket(Component.translatable("chat.disabled.options").withStyle(ChatFormatting.RED), false));
-        } else {
+        }
+        else
+        {
             this.player.resetLastActionTime();
             // CraftBukkit start
-            if (sync) {
+            if (sync)
+            {
                 this.server.execute(runnable);
-            } else {
+            }
+            else
+            {
                 runnable.run();
             }
             // CraftBukkit end
         }
     }
 
-    private Optional<LastSeenMessages> unpackAndApplyLastSeen(LastSeenMessages.Update acknowledgment) {
+    private Optional<LastSeenMessages> unpackAndApplyLastSeen(LastSeenMessages.Update acknowledgment)
+    {
         LastSeenMessagesValidator lastseenmessagesvalidator = this.lastSeenMessages;
 
-        synchronized (this.lastSeenMessages) {
+        synchronized (this.lastSeenMessages)
+        {
             Optional<LastSeenMessages> optional = this.lastSeenMessages.applyUpdate(acknowledgment);
 
-            if (optional.isEmpty()) {
+            if (optional.isEmpty())
+            {
                 ServerGamePacketListenerImpl.LOGGER.warn("Failed to validate message acknowledgements from {}", this.player.getName().getString());
                 this.disconnect(ServerGamePacketListenerImpl.CHAT_VALIDATION_FAILED, org.bukkit.event.player.PlayerKickEvent.Cause.CHAT_VALIDATION_FAILED); // Paper - kick event causes
             }
@@ -2360,9 +2686,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    public static boolean isChatMessageIllegal(String message) {
-        for (int i = 0; i < message.length(); ++i) {
-            if (!StringUtil.isAllowedChatCharacter(message.charAt(i))) {
+    public static boolean isChatMessageIllegal(String message)
+    {
+        for (int i = 0; i < message.length(); ++i)
+        {
+            if (!StringUtil.isAllowedChatCharacter(message.charAt(i)))
+            {
                 return true;
             }
         }
@@ -2371,91 +2700,129 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     // CraftBukkit start - add method
-    public void chat(String s, PlayerChatMessage original, boolean async) {
-        if (s.isEmpty() || this.player.getChatVisibility() == ChatVisiblity.HIDDEN) {
+    public void chat(String s, PlayerChatMessage original, boolean async)
+    {
+        if (s.isEmpty() || this.player.getChatVisibility() == ChatVisiblity.HIDDEN)
+        {
             return;
         }
         OutgoingChatMessage outgoing = OutgoingChatMessage.create(original);
 
-        if (false && !async && s.startsWith("/")) { // Paper - Don't handle commands in chat logic
+        if (false && !async && s.startsWith("/"))
+        { // Paper - Don't handle commands in chat logic
             this.handleCommand(s);
-        } else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM) {
+        }
+        else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM)
+        {
             // Do nothing, this is coming from a plugin
-        // Paper start
-        } else if (true) {
-            if (!async && !org.bukkit.Bukkit.isPrimaryThread()) {
+            // Paper start
+        }
+        else if (true)
+        {
+            if (!async && !org.bukkit.Bukkit.isPrimaryThread())
+            {
                 org.spigotmc.AsyncCatcher.catchOp("Asynchronous player chat is not allowed here");
             }
             final ChatProcessor cp = new ChatProcessor(this.server, this.player, original, async);
             cp.process();
             // Paper end
-        } else if (false) { // Paper
+        }
+        else if (false)
+        { // Paper
             Player player = this.getCraftPlayer();
             AsyncPlayerChatEvent event = new AsyncPlayerChatEvent(async, player, s, new LazyPlayerSet(this.server));
             String originalFormat = event.getFormat(), originalMessage = event.getMessage();
             this.cserver.getPluginManager().callEvent(event);
 
-            if (PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0) {
+            if (PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0)
+            {
                 // Evil plugins still listening to deprecated event
                 final PlayerChatEvent queueEvent = new PlayerChatEvent(player, event.getMessage(), event.getFormat(), event.getRecipients());
                 queueEvent.setCancelled(event.isCancelled());
-                Waitable waitable = new Waitable() {
+                Waitable waitable = new Waitable()
+                {
                     @Override
-                    protected Object evaluate() {
+                    protected Object evaluate()
+                    {
                         org.bukkit.Bukkit.getPluginManager().callEvent(queueEvent);
 
-                        if (queueEvent.isCancelled()) {
+                        if (queueEvent.isCancelled())
+                        {
                             return null;
                         }
 
                         String message = String.format(queueEvent.getFormat(), queueEvent.getPlayer().getDisplayName(), queueEvent.getMessage());
-                        if (((LazyPlayerSet) queueEvent.getRecipients()).isLazy()) {
-                            if (!org.spigotmc.SpigotConfig.bungee && originalFormat.equals(queueEvent.getFormat()) && originalMessage.equals(queueEvent.getMessage()) && queueEvent.getPlayer().getName().equalsIgnoreCase(queueEvent.getPlayer().getDisplayName())) { // Spigot
+                        if (((LazyPlayerSet) queueEvent.getRecipients()).isLazy())
+                        {
+                            if (!org.spigotmc.SpigotConfig.bungee && originalFormat.equals(queueEvent.getFormat()) && originalMessage.equals(queueEvent.getMessage()) && queueEvent.getPlayer().getName().equalsIgnoreCase(queueEvent.getPlayer().getDisplayName()))
+                            { // Spigot
                                 ServerGamePacketListenerImpl.this.server.getPlayerList().broadcastChatMessage(original, ServerGamePacketListenerImpl.this.player, ChatType.bind(ChatType.CHAT, (Entity) ServerGamePacketListenerImpl.this.player));
                                 return null;
                             }
 
-                            for (ServerPlayer recipient : ServerGamePacketListenerImpl.this.server.getPlayerList().players) {
+                            for (ServerPlayer recipient : ServerGamePacketListenerImpl.this.server.getPlayerList().players)
+                            {
                                 recipient.getBukkitEntity().sendMessage(ServerGamePacketListenerImpl.this.player.getUUID(), message);
                             }
-                        } else {
-                            for (Player player : queueEvent.getRecipients()) {
+                        }
+                        else
+                        {
+                            for (Player player : queueEvent.getRecipients())
+                            {
                                 player.sendMessage(ServerGamePacketListenerImpl.this.player.getUUID(), message);
                             }
                         }
                         ServerGamePacketListenerImpl.this.server.console.sendMessage(message);
 
                         return null;
-                    }};
-                if (async) {
+                    }
+                };
+                if (async)
+                {
                     this.server.processQueue.add(waitable);
-                } else {
+                }
+                else
+                {
                     waitable.run();
                 }
-                try {
+                try
+                {
                     waitable.get();
-                } catch (InterruptedException e) {
+                }
+                catch (InterruptedException e)
+                {
                     Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
-                } catch (ExecutionException e) {
+                }
+                catch (ExecutionException e)
+                {
                     throw new RuntimeException("Exception processing chat event", e.getCause());
                 }
-            } else {
-                if (event.isCancelled()) {
+            }
+            else
+            {
+                if (event.isCancelled())
+                {
                     return;
                 }
 
                 s = String.format(event.getFormat(), event.getPlayer().getDisplayName(), event.getMessage());
-                if (((LazyPlayerSet) event.getRecipients()).isLazy()) {
-                    if (!org.spigotmc.SpigotConfig.bungee && originalFormat.equals(event.getFormat()) && originalMessage.equals(event.getMessage()) && event.getPlayer().getName().equalsIgnoreCase(event.getPlayer().getDisplayName())) { // Spigot
+                if (((LazyPlayerSet) event.getRecipients()).isLazy())
+                {
+                    if (!org.spigotmc.SpigotConfig.bungee && originalFormat.equals(event.getFormat()) && originalMessage.equals(event.getMessage()) && event.getPlayer().getName().equalsIgnoreCase(event.getPlayer().getDisplayName()))
+                    { // Spigot
                         ServerGamePacketListenerImpl.this.server.getPlayerList().broadcastChatMessage(original, ServerGamePacketListenerImpl.this.player, ChatType.bind(ChatType.CHAT, (Entity) ServerGamePacketListenerImpl.this.player));
                         return;
                     }
 
-                    for (ServerPlayer recipient : this.server.getPlayerList().players) {
+                    for (ServerPlayer recipient : this.server.getPlayerList().players)
+                    {
                         recipient.getBukkitEntity().sendMessage(ServerGamePacketListenerImpl.this.player.getUUID(), s);
                     }
-                } else {
-                    for (Player recipient : event.getRecipients()) {
+                }
+                else
+                {
+                    for (Player recipient : event.getRecipients())
+                    {
                         recipient.sendMessage(ServerGamePacketListenerImpl.this.player.getUUID(), s);
                     }
                 }
@@ -2464,58 +2831,79 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
     }
 
-    public void handleCommand(String s) { // Paper - private -> public
+    public void handleCommand(String s)
+    { // Paper - private -> public
         org.spigotmc.AsyncCatcher.catchOp("Command Dispatched Async: " + s); // Paper - Add async catcher
         co.aikar.timings.MinecraftTimings.playerCommandTimer.startTiming(); // Paper
-        if ( org.spigotmc.SpigotConfig.logCommands ) // Spigot
-        this.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + s);
+        if (org.spigotmc.SpigotConfig.logCommands) // Spigot
+        {
+            this.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + s);
+        }
 
         CraftPlayer player = this.getCraftPlayer();
 
         PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(player, s, new LazyPlayerSet(this.server));
         this.cserver.getPluginManager().callEvent(event);
 
-        if (event.isCancelled()) {
+        if (event.isCancelled())
+        {
             co.aikar.timings.MinecraftTimings.playerCommandTimer.stopTiming(); // Paper
             return;
         }
 
-        try {
-            if (this.cserver.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
+        try
+        {
+            if (this.cserver.dispatchCommand(event.getPlayer(), event.getMessage().substring(1)))
+            {
                 return;
             }
-        } catch (org.bukkit.command.CommandException ex) {
+        }
+        catch (org.bukkit.command.CommandException ex)
+        {
             player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
             java.util.logging.Logger.getLogger(ServerGamePacketListenerImpl.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
             return;
-        } finally {
+        }
+        finally
+        {
             co.aikar.timings.MinecraftTimings.playerCommandTimer.stopTiming(); // Paper
         }
     }
     // CraftBukkit end
 
-    private PlayerChatMessage getSignedMessage(ServerboundChatPacket packet, LastSeenMessages lastSeenMessages) throws SignedMessageChain.DecodeException {
+    private PlayerChatMessage getSignedMessage(ServerboundChatPacket packet, LastSeenMessages lastSeenMessages) throws SignedMessageChain.DecodeException
+    {
         SignedMessageBody signedmessagebody = new SignedMessageBody(packet.message(), packet.timeStamp(), packet.salt(), lastSeenMessages);
 
         return this.signedMessageDecoder.unpack(packet.signature(), signedmessagebody);
     }
 
-    private void broadcastChatMessage(PlayerChatMessage message) {
+    private void broadcastChatMessage(PlayerChatMessage message)
+    {
         // CraftBukkit start
         String s = message.signedContent();
-        if (s.isEmpty()) {
+        if (s.isEmpty())
+        {
             ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send an empty message");
-        } else if (this.getCraftPlayer().isConversing()) {
+        }
+        else if (this.getCraftPlayer().isConversing())
+        {
             final String conversationInput = s;
-            this.server.processQueue.add(new Runnable() {
+            this.server.processQueue.add(new Runnable()
+            {
                 @Override
-                public void run() {
+                public void run()
+                {
                     ServerGamePacketListenerImpl.this.getCraftPlayer().acceptConversationInput(conversationInput);
                 }
             });
-        } else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM) { // Re-add "Command Only" flag check
+        }
+        else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM)
+        { // Re-add "Command Only" flag check
             this.send(new ClientboundSystemChatPacket(Component.translatable("chat.cannotSend").withStyle(ChatFormatting.RED), false));
-        } else {
+        }
+        else
+        {
             this.chat(s, message, true);
         }
         // this.server.getPlayerList().broadcastChatMessage(playerchatmessage, this.player, ChatMessageType.bind(ChatMessageType.CHAT, (Entity) this.player));
@@ -2524,12 +2912,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     // Spigot start - spam exclusions
-    private void detectRateSpam(String s) {
+    private void detectRateSpam(String s)
+    {
         // CraftBukkit start - replaced with thread safe throttle
         boolean counted = true;
-        for ( String exclude : org.spigotmc.SpigotConfig.spamExclusions )
+        for (String exclude : org.spigotmc.SpigotConfig.spamExclusions)
         {
-            if ( exclude != null && s.startsWith( exclude ) )
+            if (exclude != null && s.startsWith(exclude))
             {
                 counted = false;
                 break;
@@ -2537,7 +2926,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         }
         // Spigot end
         // this.chatSpamTickCount += 20;
-        if (counted && this.chatSpamTickCount.addAndGet(20) > 200 && !this.server.getPlayerList().isOp(this.player.getGameProfile())) { // Paper - exclude from SpigotConfig.spamExclusions
+        if (counted && this.chatSpamTickCount.addAndGet(20) > 200 && !this.server.getPlayerList().isOp(this.player.getGameProfile()))
+        { // Paper - exclude from SpigotConfig.spamExclusions
             // CraftBukkit end
             this.disconnect(Component.translatable("disconnect.spam"), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM); // Paper - kick event cause
         }
@@ -2545,11 +2935,14 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleChatAck(ServerboundChatAckPacket packet) {
+    public void handleChatAck(ServerboundChatAckPacket packet)
+    {
         LastSeenMessagesValidator lastseenmessagesvalidator = this.lastSeenMessages;
 
-        synchronized (this.lastSeenMessages) {
-            if (!this.lastSeenMessages.applyOffset(packet.offset())) {
+        synchronized (this.lastSeenMessages)
+        {
+            if (!this.lastSeenMessages.applyOffset(packet.offset()))
+            {
                 ServerGamePacketListenerImpl.LOGGER.warn("Failed to validate message acknowledgements from {}", this.player.getName().getString());
                 this.disconnect(ServerGamePacketListenerImpl.CHAT_VALIDATION_FAILED, org.bukkit.event.player.PlayerKickEvent.Cause.CHAT_VALIDATION_FAILED); // Paper - kick event causes
             }
@@ -2558,9 +2951,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleAnimate(ServerboundSwingPacket packet) {
+    public void handleAnimate(ServerboundSwingPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
         this.player.resetLastActionTime();
         // CraftBukkit start - Raytrace to look for 'rogue armswings'
         float f1 = this.player.getXRot();
@@ -2573,17 +2970,24 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         double d3 = this.player.gameMode.getGameModeForPlayer() == GameType.CREATIVE ? 5.0D : 4.5D;
         // SPIGOT-5607: Only call interact event if no block or entity is being clicked. Use bukkit ray trace method, because it handles blocks and entities at the same time
         // SPIGOT-7429: Make sure to call PlayerInteractEvent for spectators and non-pickable entities
-        org.bukkit.util.RayTraceResult result = this.player.level().getWorld().rayTrace(origin, origin.getDirection(), d3, org.bukkit.FluidCollisionMode.NEVER, false, 0.0, entity -> { // Paper - Call interact event; change raySize from 0.1 to 0.0
+        org.bukkit.util.RayTraceResult result = this.player.level().getWorld().rayTrace(origin, origin.getDirection(), d3, org.bukkit.FluidCollisionMode.NEVER, false, 0.0, entity ->
+        { // Paper - Call interact event; change raySize from 0.1 to 0.0
             Entity handle = ((CraftEntity) entity).getHandle();
             return entity != this.player.getBukkitEntity() && this.player.getBukkitEntity().canSee(entity) && !handle.isSpectator() && handle.isPickable() && !handle.isPassengerOfSameVehicle(this.player);
         });
-        if (result == null) {
+        if (result == null)
+        {
             CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_AIR, this.player.getInventory().getSelected(), InteractionHand.MAIN_HAND);
-        } else { // Paper start - Call interact event
+        }
+        else
+        { // Paper start - Call interact event
             GameType gameType = this.player.gameMode.getGameModeForPlayer();
-            if (gameType == GameType.ADVENTURE && result.getHitBlock() != null) {
+            if (gameType == GameType.ADVENTURE && result.getHitBlock() != null)
+            {
                 CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_BLOCK, ((org.bukkit.craftbukkit.block.CraftBlock) result.getHitBlock()).getPosition(), org.bukkit.craftbukkit.block.CraftBlock.blockFaceToNotch(result.getHitBlockFace()), this.player.getInventory().getSelected(), InteractionHand.MAIN_HAND);
-            } else if (gameType != GameType.CREATIVE && result.getHitEntity() != null && origin.toVector().distanceSquared(result.getHitPosition()) > 3.0D * 3.0D) {
+            }
+            else if (gameType != GameType.CREATIVE && result.getHitEntity() != null && origin.toVector().distanceSquared(result.getHitPosition()) > 3.0D * 3.0D)
+            {
                 CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_AIR, this.player.getInventory().getSelected(), InteractionHand.MAIN_HAND);
             }
         } // Paper end - Call interact event
@@ -2592,23 +2996,32 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         io.papermc.paper.event.player.PlayerArmSwingEvent event = new io.papermc.paper.event.player.PlayerArmSwingEvent(this.getCraftPlayer(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(packet.getHand())); // Paper - Add PlayerArmSwingEvent
         this.cserver.getPluginManager().callEvent(event);
 
-        if (event.isCancelled()) return;
+        if (event.isCancelled())
+        {
+            return;
+        }
         // CraftBukkit end
         this.player.swing(packet.getHand());
     }
 
     @Override
-    public void handlePlayerCommand(ServerboundPlayerCommandPacket packet) {
+    public void handlePlayerCommand(ServerboundPlayerCommandPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         // CraftBukkit start
-        if (this.player.isRemoved()) return;
-        switch (packet.getAction()) {
+        if (this.player.isRemoved())
+        {
+            return;
+        }
+        switch (packet.getAction())
+        {
             case PRESS_SHIFT_KEY:
             case RELEASE_SHIFT_KEY:
                 PlayerToggleSneakEvent event = new PlayerToggleSneakEvent(this.getCraftPlayer(), packet.getAction() == ServerboundPlayerCommandPacket.Action.PRESS_SHIFT_KEY);
                 this.cserver.getPluginManager().callEvent(event);
 
-                if (event.isCancelled()) {
+                if (event.isCancelled())
+                {
                     return;
                 }
                 break;
@@ -2617,7 +3030,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 PlayerToggleSprintEvent e2 = new PlayerToggleSprintEvent(this.getCraftPlayer(), packet.getAction() == ServerboundPlayerCommandPacket.Action.START_SPRINTING);
                 this.cserver.getPluginManager().callEvent(e2);
 
-                if (e2.isCancelled()) {
+                if (e2.isCancelled())
+                {
                     return;
                 }
                 break;
@@ -2626,12 +3040,14 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         this.player.resetLastActionTime();
         Entity entity;
 
-        switch (packet.getAction()) {
+        switch (packet.getAction())
+        {
             case PRESS_SHIFT_KEY:
                 this.player.setShiftKeyDown(true);
 
                 // Paper start - Add option to make parrots stay
-                if (this.player.level().paperConfig().entities.behavior.parrotsAreUnaffectedByPlayerMovement) {
+                if (this.player.level().paperConfig().entities.behavior.parrotsAreUnaffectedByPlayerMovement)
+                {
                     this.player.removeEntitiesOnShoulder();
                 }
                 // Paper end - Add option to make parrots stay
@@ -2647,35 +3063,41 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 this.player.setSprinting(false);
                 break;
             case STOP_SLEEPING:
-                if (this.player.isSleeping()) {
+                if (this.player.isSleeping())
+                {
                     this.player.stopSleepInBed(false, true);
                     this.awaitingPositionFromClient = this.player.position();
                 }
                 break;
             case START_RIDING_JUMP:
                 entity = this.player.getControlledVehicle();
-                if (entity instanceof PlayerRideableJumping ijumpable) {
+                if (entity instanceof PlayerRideableJumping ijumpable)
+                {
                     int i = packet.getData();
 
-                    if (ijumpable.canJump() && i > 0) {
+                    if (ijumpable.canJump() && i > 0)
+                    {
                         ijumpable.handleStartJump(i);
                     }
                 }
                 break;
             case STOP_RIDING_JUMP:
                 entity = this.player.getControlledVehicle();
-                if (entity instanceof PlayerRideableJumping ijumpable) {
+                if (entity instanceof PlayerRideableJumping ijumpable)
+                {
                     ijumpable.handleStopJump();
                 }
                 break;
             case OPEN_INVENTORY:
                 entity = this.player.getVehicle();
-                if (entity instanceof HasCustomInventoryScreen hascustominventoryscreen) {
+                if (entity instanceof HasCustomInventoryScreen hascustominventoryscreen)
+                {
                     hascustominventoryscreen.openCustomInventoryScreen(this.player);
                 }
                 break;
             case START_FALL_FLYING:
-                if (!this.player.tryToStartFallFlying()) {
+                if (!this.player.tryToStartFallFlying())
+                {
                     this.player.stopFallFlying();
                 }
                 break;
@@ -2685,33 +3107,39 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     }
 
-    public void addPendingMessage(PlayerChatMessage message) {
+    public void addPendingMessage(PlayerChatMessage message)
+    {
         MessageSignature messagesignature = message.signature();
 
-        if (messagesignature != null) {
+        if (messagesignature != null)
+        {
             this.messageSignatureCache.push(message.signedBody(), message.signature());
             LastSeenMessagesValidator lastseenmessagesvalidator = this.lastSeenMessages;
             int i;
 
-            synchronized (this.lastSeenMessages) {
+            synchronized (this.lastSeenMessages)
+            {
                 this.lastSeenMessages.addPending(messagesignature);
                 i = this.lastSeenMessages.trackedMessagesCount();
             }
 
-            if (i > 4096) {
+            if (i > 4096)
+            {
                 this.disconnect(Component.translatable("multiplayer.disconnect.too_many_pending_chats"), org.bukkit.event.player.PlayerKickEvent.Cause.TOO_MANY_PENDING_CHATS); // Paper - kick event cause
             }
 
         }
     }
 
-    public void sendPlayerChatMessage(PlayerChatMessage message, ChatType.Bound params) {
+    public void sendPlayerChatMessage(PlayerChatMessage message, ChatType.Bound params)
+    {
         // CraftBukkit start - SPIGOT-7262: if hidden we have to send as disguised message. Query whether we should send at all (but changing this may not be expected).
         // Paper start - Do not query the world for players, if they're not in the player list, then they're not in the world - don't query world state
         // Also, mirror the logic for canSee in terms of "missing" players
         final ServerPlayer sender = this.server.getPlayerList().getPlayer(message.link().sender());
-        if (sender == null || !this.getCraftPlayer().canSee(sender.getBukkitEntity())) {
-        // Paper end
+        if (sender == null || !this.getCraftPlayer().canSee(sender.getBukkitEntity()))
+        {
+            // Paper end
             this.sendDisguisedChatMessage(message.decoratedContent(), params);
             return;
         }
@@ -2720,11 +3148,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         this.addPendingMessage(message);
     }
 
-    public void sendDisguisedChatMessage(Component message, ChatType.Bound params) {
+    public void sendDisguisedChatMessage(Component message, ChatType.Bound params)
+    {
         this.send(new ClientboundDisguisedChatPacket(message, params));
     }
 
-    public SocketAddress getRemoteAddress() {
+    public SocketAddress getRemoteAddress()
+    {
         return this.connection.getRemoteAddress();
     }
 
@@ -2732,7 +3162,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     public SocketAddress getRawAddress()
     {
         // Paper start - Unix domain socket support; this can be nullable in the case of a Unix domain socket, so if it is, fake something
-        if (connection.channel.remoteAddress() == null) {
+        if (connection.channel.remoteAddress() == null)
+        {
             return new java.net.InetSocketAddress(java.net.InetAddress.getLoopbackAddress(), 0);
         }
         // Paper end - Unix domain socket support
@@ -2740,7 +3171,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
     // Spigot End
 
-    public void switchToConfig() {
+    public void switchToConfig()
+    {
         this.waitingForSwitchToConfig = true;
         this.removePlayerFromWorld();
         this.send(ClientboundStartConfigurationPacket.INSTANCE);
@@ -2748,39 +3180,50 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handlePingRequest(ServerboundPingRequestPacket packet) {
+    public void handlePingRequest(ServerboundPingRequestPacket packet)
+    {
         this.connection.send(new ClientboundPongResponsePacket(packet.getTime()));
     }
 
     @Override
-    public void handleInteract(ServerboundInteractPacket packet) {
+    public void handleInteract(ServerboundInteractPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
         final ServerLevel worldserver = this.player.serverLevel();
         final Entity entity = packet.getTarget(worldserver);
         // Spigot Start
-        if ( entity == this.player && !this.player.isSpectator() )
+        if (entity == this.player && !this.player.isSpectator())
         {
-            this.disconnect( "Cannot interact with self!" , org.bukkit.event.player.PlayerKickEvent.Cause.SELF_INTERACTION ); // Paper - kick event cause
+            this.disconnect("Cannot interact with self!", org.bukkit.event.player.PlayerKickEvent.Cause.SELF_INTERACTION); // Paper - kick event cause
             return;
         }
         // Spigot End
 
         this.player.resetLastActionTime();
         this.player.setShiftKeyDown(packet.isUsingSecondaryAction());
-        if (entity != null) {
-            if (!worldserver.getWorldBorder().isWithinBounds(entity.blockPosition())) {
+        if (entity != null)
+        {
+            if (!worldserver.getWorldBorder().isWithinBounds(entity.blockPosition()))
+            {
                 return;
             }
 
             AABB axisalignedbb = entity.getBoundingBox();
 
-            if (this.player.canInteractWithEntity(axisalignedbb, 1.0D)) {
-                packet.dispatch(new ServerboundInteractPacket.Handler() {
-                    private void performInteraction(InteractionHand enumhand, ServerGamePacketListenerImpl.EntityInteraction playerconnection_a, PlayerInteractEntityEvent event) { // CraftBukkit
+            if (this.player.canInteractWithEntity(axisalignedbb, 1.0D))
+            {
+                packet.dispatch(new ServerboundInteractPacket.Handler()
+                {
+                    private void performInteraction(InteractionHand enumhand, ServerGamePacketListenerImpl.EntityInteraction playerconnection_a, PlayerInteractEntityEvent event)
+                    { // CraftBukkit
                         ItemStack itemstack = ServerGamePacketListenerImpl.this.player.getItemInHand(enumhand);
 
-                        if (itemstack.isItemEnabled(worldserver.enabledFeatures())) {
+                        if (itemstack.isItemEnabled(worldserver.enabledFeatures()))
+                        {
                             ItemStack itemstack1 = itemstack.copy();
                             // CraftBukkit start
                             ItemStack itemInHand = ServerGamePacketListenerImpl.this.player.getItemInHand(enumhand);
@@ -2790,27 +3233,32 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             ServerGamePacketListenerImpl.this.cserver.getPluginManager().callEvent(event);
 
                             // Entity in bucket - SPIGOT-4048 and SPIGOT-6859a
-                            if ((entity instanceof Bucketable && entity instanceof LivingEntity && origItem != null && origItem.asItem() == Items.WATER_BUCKET) && (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelected() == null || ServerGamePacketListenerImpl.this.player.getInventory().getSelected().getItem() != origItem)) {
+                            if ((entity instanceof Bucketable && entity instanceof LivingEntity && origItem != null && origItem.asItem() == Items.WATER_BUCKET) && (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelected() == null || ServerGamePacketListenerImpl.this.player.getInventory().getSelected().getItem() != origItem))
+                            {
                                 entity.resendPossiblyDesyncedEntityData(ServerGamePacketListenerImpl.this.player); // Paper - The entire mob gets deleted, so resend it.
                                 ServerGamePacketListenerImpl.this.player.containerMenu.sendAllDataToRemote();
                             }
 
-                            if (triggerLeashUpdate && (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelected() == null || ServerGamePacketListenerImpl.this.player.getInventory().getSelected().getItem() != origItem)) {
+                            if (triggerLeashUpdate && (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelected() == null || ServerGamePacketListenerImpl.this.player.getInventory().getSelected().getItem() != origItem))
+                            {
                                 // Refresh the current leash state
                                 ServerGamePacketListenerImpl.this.send(new ClientboundSetEntityLinkPacket(entity, ((Mob) entity).getLeashHolder()));
                             }
 
-                            if (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelected() == null || ServerGamePacketListenerImpl.this.player.getInventory().getSelected().getItem() != origItem) {
+                            if (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelected() == null || ServerGamePacketListenerImpl.this.player.getInventory().getSelected().getItem() != origItem)
+                            {
                                 // Refresh the current entity metadata
                                 entity.refreshEntityData(ServerGamePacketListenerImpl.this.player);
                                 // SPIGOT-7136 - Allays
-                                if (entity instanceof Allay) {
+                                if (entity instanceof Allay)
+                                {
                                     ServerGamePacketListenerImpl.this.send(new ClientboundSetEquipmentPacket(entity.getId(), Arrays.stream(net.minecraft.world.entity.EquipmentSlot.values()).map((slot) -> Pair.of(slot, ((LivingEntity) entity).getItemBySlot(slot).copy())).collect(Collectors.toList())));
                                     ServerGamePacketListenerImpl.this.player.containerMenu.sendAllDataToRemote();
                                 }
                             }
 
-                            if (event.isCancelled()) {
+                            if (event.isCancelled())
+                            {
                                 ServerGamePacketListenerImpl.this.player.containerMenu.sendAllDataToRemote(); // Paper - Refresh player inventory
                                 return;
                             }
@@ -2818,14 +3266,17 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             InteractionResult enuminteractionresult = playerconnection_a.run(ServerGamePacketListenerImpl.this.player, entity, enumhand);
 
                             // CraftBukkit start
-                            if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) {
+                            if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1)
+                            {
                                 ServerGamePacketListenerImpl.this.player.containerMenu.sendAllDataToRemote();
                             }
                             // CraftBukkit end
 
-                            if (enuminteractionresult.consumesAction()) {
+                            if (enuminteractionresult.consumesAction())
+                            {
                                 CriteriaTriggers.PLAYER_INTERACTED_WITH_ENTITY.trigger(ServerGamePacketListenerImpl.this.player, enuminteractionresult.indicateItemUse() ? itemstack1 : ItemStack.EMPTY, entity);
-                                if (enuminteractionresult.shouldSwing()) {
+                                if (enuminteractionresult.shouldSwing())
+                                {
                                     ServerGamePacketListenerImpl.this.player.swing(enumhand, true);
                                 }
                             }
@@ -2834,40 +3285,49 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                     }
 
                     @Override
-                    public void onInteraction(InteractionHand hand) {
+                    public void onInteraction(InteractionHand hand)
+                    {
                         this.performInteraction(hand, net.minecraft.world.entity.player.Player::interactOn, new PlayerInteractEntityEvent(ServerGamePacketListenerImpl.this.getCraftPlayer(), entity.getBukkitEntity(), (hand == InteractionHand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND)); // CraftBukkit
                     }
 
                     @Override
-                    public void onInteraction(InteractionHand hand, Vec3 pos) {
-                        this.performInteraction(hand, (entityplayer, entity1, enumhand1) -> {
+                    public void onInteraction(InteractionHand hand, Vec3 pos)
+                    {
+                        this.performInteraction(hand, (entityplayer, entity1, enumhand1) ->
+                        {
                             return entity1.interactAt(entityplayer, pos, enumhand1);
                         }, new PlayerInteractAtEntityEvent(ServerGamePacketListenerImpl.this.getCraftPlayer(), entity.getBukkitEntity(), new org.bukkit.util.Vector(pos.x, pos.y, pos.z), (hand == InteractionHand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND)); // CraftBukkit
                     }
 
                     @Override
-                    public void onAttack() {
+                    public void onAttack()
+                    {
                         // CraftBukkit
-                        if (!(entity instanceof ItemEntity) && !(entity instanceof ExperienceOrb) && (entity != ServerGamePacketListenerImpl.this.player || ServerGamePacketListenerImpl.this.player.isSpectator())) {
+                        if (!(entity instanceof ItemEntity) && !(entity instanceof ExperienceOrb) && (entity != ServerGamePacketListenerImpl.this.player || ServerGamePacketListenerImpl.this.player.isSpectator()))
+                        {
                             label23:
                             {
-                                if (entity instanceof AbstractArrow) {
+                                if (entity instanceof AbstractArrow)
+                                {
                                     AbstractArrow entityarrow = (AbstractArrow) entity;
 
-                                    if (!entityarrow.isAttackable()) {
+                                    if (!entityarrow.isAttackable())
+                                    {
                                         break label23;
                                     }
                                 }
 
                                 ItemStack itemstack = ServerGamePacketListenerImpl.this.player.getItemInHand(InteractionHand.MAIN_HAND);
 
-                                if (!itemstack.isItemEnabled(worldserver.enabledFeatures())) {
+                                if (!itemstack.isItemEnabled(worldserver.enabledFeatures()))
+                                {
                                     return;
                                 }
 
                                 ServerGamePacketListenerImpl.this.player.attack(entity);
                                 // CraftBukkit start
-                                if (!itemstack.isEmpty() && itemstack.getCount() <= -1) {
+                                if (!itemstack.isEmpty() && itemstack.getCount() <= -1)
+                                {
                                     ServerGamePacketListenerImpl.this.player.containerMenu.sendAllDataToRemote();
                                 }
                                 // CraftBukkit end
@@ -2882,20 +3342,25 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             }
         }
         // Paper start - PlayerUseUnknownEntityEvent
-        else {
-            packet.dispatch(new net.minecraft.network.protocol.game.ServerboundInteractPacket.Handler() {
+        else
+        {
+            packet.dispatch(new net.minecraft.network.protocol.game.ServerboundInteractPacket.Handler()
+            {
                 @Override
-                public void onInteraction(net.minecraft.world.InteractionHand hand) {
+                public void onInteraction(net.minecraft.world.InteractionHand hand)
+                {
                     CraftEventFactory.callPlayerUseUnknownEntityEvent(ServerGamePacketListenerImpl.this.player, packet, hand, null);
                 }
 
                 @Override
-                public void onInteraction(net.minecraft.world.InteractionHand hand, net.minecraft.world.phys.Vec3 pos) {
+                public void onInteraction(net.minecraft.world.InteractionHand hand, net.minecraft.world.phys.Vec3 pos)
+                {
                     CraftEventFactory.callPlayerUseUnknownEntityEvent(ServerGamePacketListenerImpl.this.player, packet, hand, pos);
                 }
 
                 @Override
-                public void onAttack() {
+                public void onAttack()
+                {
                     CraftEventFactory.callPlayerUseUnknownEntityEvent(ServerGamePacketListenerImpl.this.player, packet, net.minecraft.world.InteractionHand.MAIN_HAND, null);
                 }
             });
@@ -2904,24 +3369,31 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleClientCommand(ServerboundClientCommandPacket packet) {
+    public void handleClientCommand(ServerboundClientCommandPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         this.player.resetLastActionTime();
         ServerboundClientCommandPacket.Action packetplayinclientcommand_enumclientcommand = packet.getAction();
 
-        switch (packetplayinclientcommand_enumclientcommand) {
+        switch (packetplayinclientcommand_enumclientcommand)
+        {
             case PERFORM_RESPAWN:
-                if (this.player.wonGame) {
+                if (this.player.wonGame)
+                {
                     this.player.wonGame = false;
                     this.player = this.server.getPlayerList().respawn(this.player, this.server.getLevel(this.player.getRespawnDimension()), true, null, true, RespawnReason.END_PORTAL, org.bukkit.event.player.PlayerRespawnEvent.RespawnFlag.END_PORTAL); // Paper - Expand PlayerRespawnEvent
                     CriteriaTriggers.CHANGED_DIMENSION.trigger(this.player, Level.END, Level.OVERWORLD);
-                } else {
-                    if (this.player.getHealth() > 0.0F) {
+                }
+                else
+                {
+                    if (this.player.getHealth() > 0.0F)
+                    {
                         return;
                     }
 
                     this.player = this.server.getPlayerList().respawn(this.player, false, RespawnReason.DEATH);
-                    if (this.server.isHardcore()) {
+                    if (this.server.isHardcore())
+                    {
                         this.player.setGameMode(GameType.SPECTATOR, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.HARDCORE_DEATH, null); // Paper - Expand PlayerGameModeChangeEvent
                         ((GameRules.BooleanValue) this.player.level().getGameRules().getRule(GameRules.RULE_SPECTATORSGENERATECHUNKS)).set(false, this.player.serverLevel()); // CraftBukkit - per-world
                     }
@@ -2934,42 +3406,62 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleContainerClose(ServerboundContainerClosePacket packet) {
+    public void handleContainerClose(ServerboundContainerClosePacket packet)
+    {
         // Paper start - Inventory close reason
         this.handleContainerClose(packet, org.bukkit.event.inventory.InventoryCloseEvent.Reason.PLAYER);
     }
-    public void handleContainerClose(ServerboundContainerClosePacket packet, org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
+
+    public void handleContainerClose(ServerboundContainerClosePacket packet, org.bukkit.event.inventory.InventoryCloseEvent.Reason reason)
+    {
         // Paper end - Inventory close reason
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
 
-        if (this.player.isImmobile()) return; // CraftBukkit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
         CraftEventFactory.handleInventoryCloseEvent(this.player, reason); // CraftBukkit // Paper
 
         this.player.doCloseContainer();
     }
 
     @Override
-    public void handleContainerClick(ServerboundContainerClickPacket packet) {
+    public void handleContainerClick(ServerboundContainerClickPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
         this.player.resetLastActionTime();
-        if (this.player.containerMenu.containerId == packet.getContainerId() && this.player.containerMenu.stillValid(this.player)) { // CraftBukkit
+        if (this.player.containerMenu.containerId == packet.getContainerId() && this.player.containerMenu.stillValid(this.player))
+        { // CraftBukkit
             boolean cancelled = this.player.isSpectator(); // CraftBukkit - see below if
-            if (false/*this.player.isSpectator()*/) { // CraftBukkit
+            if (false/*this.player.isSpectator()*/)
+            { // CraftBukkit
                 this.player.containerMenu.sendAllDataToRemote();
-            } else if (!this.player.containerMenu.stillValid(this.player)) {
+            }
+            else if (!this.player.containerMenu.stillValid(this.player))
+            {
                 ServerGamePacketListenerImpl.LOGGER.debug("Player {} interacted with invalid menu {}", this.player, this.player.containerMenu);
-            } else {
+            }
+            else
+            {
                 int i = packet.getSlotNum();
 
-                if (!this.player.containerMenu.isValidSlotIndex(i)) {
+                if (!this.player.containerMenu.isValidSlotIndex(i))
+                {
                     ServerGamePacketListenerImpl.LOGGER.debug("Player {} clicked invalid slot index: {}, available slots: {}", new Object[]{this.player.getName(), i, this.player.containerMenu.slots.size()});
-                } else {
+                }
+                else
+                {
                     boolean flag = packet.getStateId() != this.player.containerMenu.getStateId();
 
                     this.player.containerMenu.suppressRemoteUpdates();
                     // CraftBukkit start - Call InventoryClickEvent
-                    if (packet.getSlotNum() < -1 && packet.getSlotNum() != -999) {
+                    if (packet.getSlotNum() < -1 && packet.getSlotNum() != -999)
+                    {
                         return;
                     }
 
@@ -2982,53 +3474,86 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                     ItemStack itemstack = ItemStack.EMPTY;
 
-                    switch (packet.getClickType()) {
+                    switch (packet.getClickType())
+                    {
                         case PICKUP:
-                            if (packet.getButtonNum() == 0) {
+                            if (packet.getButtonNum() == 0)
+                            {
                                 click = ClickType.LEFT;
-                            } else if (packet.getButtonNum() == 1) {
+                            }
+                            else if (packet.getButtonNum() == 1)
+                            {
                                 click = ClickType.RIGHT;
                             }
-                            if (packet.getButtonNum() == 0 || packet.getButtonNum() == 1) {
+                            if (packet.getButtonNum() == 0 || packet.getButtonNum() == 1)
+                            {
                                 action = InventoryAction.NOTHING; // Don't want to repeat ourselves
-                                if (packet.getSlotNum() == -999) {
-                                    if (!this.player.containerMenu.getCarried().isEmpty()) {
+                                if (packet.getSlotNum() == -999)
+                                {
+                                    if (!this.player.containerMenu.getCarried().isEmpty())
+                                    {
                                         action = packet.getButtonNum() == 0 ? InventoryAction.DROP_ALL_CURSOR : InventoryAction.DROP_ONE_CURSOR;
                                     }
-                                } else if (packet.getSlotNum() < 0)  {
+                                }
+                                else if (packet.getSlotNum() < 0)
+                                {
                                     action = InventoryAction.NOTHING;
-                                } else {
+                                }
+                                else
+                                {
                                     Slot slot = this.player.containerMenu.getSlot(packet.getSlotNum());
-                                    if (slot != null) {
+                                    if (slot != null)
+                                    {
                                         ItemStack clickedItem = slot.getItem();
                                         ItemStack cursor = this.player.containerMenu.getCarried();
-                                        if (clickedItem.isEmpty()) {
-                                            if (!cursor.isEmpty()) {
+                                        if (clickedItem.isEmpty())
+                                        {
+                                            if (!cursor.isEmpty())
+                                            {
                                                 action = packet.getButtonNum() == 0 ? InventoryAction.PLACE_ALL : InventoryAction.PLACE_ONE;
                                             }
-                                        } else if (slot.mayPickup(this.player)) {
-                                            if (cursor.isEmpty()) {
+                                        }
+                                        else if (slot.mayPickup(this.player))
+                                        {
+                                            if (cursor.isEmpty())
+                                            {
                                                 action = packet.getButtonNum() == 0 ? InventoryAction.PICKUP_ALL : InventoryAction.PICKUP_HALF;
-                                            } else if (slot.mayPlace(cursor)) {
-                                                if (ItemStack.isSameItemSameComponents(clickedItem, cursor)) {
+                                            }
+                                            else if (slot.mayPlace(cursor))
+                                            {
+                                                if (ItemStack.isSameItemSameComponents(clickedItem, cursor))
+                                                {
                                                     int toPlace = packet.getButtonNum() == 0 ? cursor.getCount() : 1;
                                                     toPlace = Math.min(toPlace, clickedItem.getMaxStackSize() - clickedItem.getCount());
                                                     toPlace = Math.min(toPlace, slot.container.getMaxStackSize() - clickedItem.getCount());
-                                                    if (toPlace == 1) {
+                                                    if (toPlace == 1)
+                                                    {
                                                         action = InventoryAction.PLACE_ONE;
-                                                    } else if (toPlace == cursor.getCount()) {
+                                                    }
+                                                    else if (toPlace == cursor.getCount())
+                                                    {
                                                         action = InventoryAction.PLACE_ALL;
-                                                    } else if (toPlace < 0) {
+                                                    }
+                                                    else if (toPlace < 0)
+                                                    {
                                                         action = toPlace != -1 ? InventoryAction.PICKUP_SOME : InventoryAction.PICKUP_ONE; // this happens with oversized stacks
-                                                    } else if (toPlace != 0) {
+                                                    }
+                                                    else if (toPlace != 0)
+                                                    {
                                                         action = InventoryAction.PLACE_SOME;
                                                     }
-                                                } else if (cursor.getCount() <= slot.getMaxStackSize()) {
+                                                }
+                                                else if (cursor.getCount() <= slot.getMaxStackSize())
+                                                {
                                                     action = InventoryAction.SWAP_WITH_CURSOR;
                                                 }
-                                            } else if (ItemStack.isSameItemSameComponents(cursor, clickedItem)) {
-                                                if (clickedItem.getCount() >= 0) {
-                                                    if (clickedItem.getCount() + cursor.getCount() <= cursor.getMaxStackSize()) {
+                                            }
+                                            else if (ItemStack.isSameItemSameComponents(cursor, clickedItem))
+                                            {
+                                                if (clickedItem.getCount() >= 0)
+                                                {
+                                                    if (clickedItem.getCount() + cursor.getCount() <= cursor.getMaxStackSize())
+                                                    {
                                                         // As of 1.5, this is result slots only
                                                         action = InventoryAction.PICKUP_ALL;
                                                     }
@@ -3041,94 +3566,139 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             break;
                         // TODO check on updates
                         case QUICK_MOVE:
-                            if (packet.getButtonNum() == 0) {
+                            if (packet.getButtonNum() == 0)
+                            {
                                 click = ClickType.SHIFT_LEFT;
-                            } else if (packet.getButtonNum() == 1) {
+                            }
+                            else if (packet.getButtonNum() == 1)
+                            {
                                 click = ClickType.SHIFT_RIGHT;
                             }
-                            if (packet.getButtonNum() == 0 || packet.getButtonNum() == 1) {
-                                if (packet.getSlotNum() < 0) {
+                            if (packet.getButtonNum() == 0 || packet.getButtonNum() == 1)
+                            {
+                                if (packet.getSlotNum() < 0)
+                                {
                                     action = InventoryAction.NOTHING;
-                                } else {
+                                }
+                                else
+                                {
                                     Slot slot = this.player.containerMenu.getSlot(packet.getSlotNum());
-                                    if (slot != null && slot.mayPickup(this.player) && slot.hasItem()) {
+                                    if (slot != null && slot.mayPickup(this.player) && slot.hasItem())
+                                    {
                                         action = InventoryAction.MOVE_TO_OTHER_INVENTORY;
-                                    } else {
+                                    }
+                                    else
+                                    {
                                         action = InventoryAction.NOTHING;
                                     }
                                 }
                             }
                             break;
                         case SWAP:
-                            if ((packet.getButtonNum() >= 0 && packet.getButtonNum() < 9) || packet.getButtonNum() == 40) {
+                            if ((packet.getButtonNum() >= 0 && packet.getButtonNum() < 9) || packet.getButtonNum() == 40)
+                            {
                                 // Paper start - Add slot sanity checks to container clicks
-                                if (packet.getSlotNum() < 0) {
+                                if (packet.getSlotNum() < 0)
+                                {
                                     action = InventoryAction.NOTHING;
                                     break;
                                 }
                                 // Paper end - Add slot sanity checks to container clicks
                                 click = (packet.getButtonNum() == 40) ? ClickType.SWAP_OFFHAND : ClickType.NUMBER_KEY;
                                 Slot clickedSlot = this.player.containerMenu.getSlot(packet.getSlotNum());
-                                if (clickedSlot.mayPickup(this.player)) {
+                                if (clickedSlot.mayPickup(this.player))
+                                {
                                     ItemStack hotbar = this.player.getInventory().getItem(packet.getButtonNum());
                                     boolean canCleanSwap = hotbar.isEmpty() || (clickedSlot.container == this.player.getInventory() && clickedSlot.mayPlace(hotbar)); // the slot will accept the hotbar item
-                                    if (clickedSlot.hasItem()) {
-                                        if (canCleanSwap) {
+                                    if (clickedSlot.hasItem())
+                                    {
+                                        if (canCleanSwap)
+                                        {
                                             action = InventoryAction.HOTBAR_SWAP;
-                                        } else {
+                                        }
+                                        else
+                                        {
                                             action = InventoryAction.HOTBAR_MOVE_AND_READD;
                                         }
-                                    } else if (!clickedSlot.hasItem() && !hotbar.isEmpty() && clickedSlot.mayPlace(hotbar)) {
+                                    }
+                                    else if (!clickedSlot.hasItem() && !hotbar.isEmpty() && clickedSlot.mayPlace(hotbar))
+                                    {
                                         action = InventoryAction.HOTBAR_SWAP;
-                                    } else {
+                                    }
+                                    else
+                                    {
                                         action = InventoryAction.NOTHING;
                                     }
-                                } else {
+                                }
+                                else
+                                {
                                     action = InventoryAction.NOTHING;
                                 }
                             }
                             break;
                         case CLONE:
-                            if (packet.getButtonNum() == 2) {
+                            if (packet.getButtonNum() == 2)
+                            {
                                 click = ClickType.MIDDLE;
-                                if (packet.getSlotNum() < 0) {
+                                if (packet.getSlotNum() < 0)
+                                {
                                     action = InventoryAction.NOTHING;
-                                } else {
+                                }
+                                else
+                                {
                                     Slot slot = this.player.containerMenu.getSlot(packet.getSlotNum());
-                                    if (slot != null && slot.hasItem() && this.player.getAbilities().instabuild && this.player.containerMenu.getCarried().isEmpty()) {
+                                    if (slot != null && slot.hasItem() && this.player.getAbilities().instabuild && this.player.containerMenu.getCarried().isEmpty())
+                                    {
                                         action = InventoryAction.CLONE_STACK;
-                                    } else {
+                                    }
+                                    else
+                                    {
                                         action = InventoryAction.NOTHING;
                                     }
                                 }
-                            } else {
+                            }
+                            else
+                            {
                                 click = ClickType.UNKNOWN;
                                 action = InventoryAction.UNKNOWN;
                             }
                             break;
                         case THROW:
-                            if (packet.getSlotNum() >= 0) {
-                                if (packet.getButtonNum() == 0) {
+                            if (packet.getSlotNum() >= 0)
+                            {
+                                if (packet.getButtonNum() == 0)
+                                {
                                     click = ClickType.DROP;
                                     Slot slot = this.player.containerMenu.getSlot(packet.getSlotNum());
-                                    if (slot != null && slot.hasItem() && slot.mayPickup(this.player) && !slot.getItem().isEmpty() && slot.getItem().getItem() != Item.byBlock(Blocks.AIR)) {
+                                    if (slot != null && slot.hasItem() && slot.mayPickup(this.player) && !slot.getItem().isEmpty() && slot.getItem().getItem() != Item.byBlock(Blocks.AIR))
+                                    {
                                         action = InventoryAction.DROP_ONE_SLOT;
-                                    } else {
+                                    }
+                                    else
+                                    {
                                         action = InventoryAction.NOTHING;
                                     }
-                                } else if (packet.getButtonNum() == 1) {
+                                }
+                                else if (packet.getButtonNum() == 1)
+                                {
                                     click = ClickType.CONTROL_DROP;
                                     Slot slot = this.player.containerMenu.getSlot(packet.getSlotNum());
-                                    if (slot != null && slot.hasItem() && slot.mayPickup(this.player) && !slot.getItem().isEmpty() && slot.getItem().getItem() != Item.byBlock(Blocks.AIR)) {
+                                    if (slot != null && slot.hasItem() && slot.mayPickup(this.player) && !slot.getItem().isEmpty() && slot.getItem().getItem() != Item.byBlock(Blocks.AIR))
+                                    {
                                         action = InventoryAction.DROP_ALL_SLOT;
-                                    } else {
+                                    }
+                                    else
+                                    {
                                         action = InventoryAction.NOTHING;
                                     }
                                 }
-                            } else {
+                            }
+                            else
+                            {
                                 // Sane default (because this happens when they are holding nothing. Don't ask why.)
                                 click = ClickType.LEFT;
-                                if (packet.getButtonNum() == 1) {
+                                if (packet.getButtonNum() == 1)
+                                {
                                     click = ClickType.RIGHT;
                                 }
                                 action = InventoryAction.NOTHING;
@@ -3140,11 +3710,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                         case PICKUP_ALL:
                             click = ClickType.DOUBLE_CLICK;
                             action = InventoryAction.NOTHING;
-                            if (packet.getSlotNum() >= 0 && !this.player.containerMenu.getCarried().isEmpty()) {
+                            if (packet.getSlotNum() >= 0 && !this.player.containerMenu.getCarried().isEmpty())
+                            {
                                 ItemStack cursor = this.player.containerMenu.getCarried();
                                 action = InventoryAction.NOTHING;
                                 // Quick check for if we have any of the item
-                                if (inventory.getTopInventory().contains(CraftItemType.minecraftToBukkit(cursor.getItem())) || inventory.getBottomInventory().contains(CraftItemType.minecraftToBukkit(cursor.getItem()))) {
+                                if (inventory.getTopInventory().contains(CraftItemType.minecraftToBukkit(cursor.getItem())) || inventory.getBottomInventory().contains(CraftItemType.minecraftToBukkit(cursor.getItem())))
+                                {
                                     action = InventoryAction.COLLECT_TO_CURSOR;
                                 }
                             }
@@ -3153,43 +3725,62 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             break;
                     }
 
-                    if (packet.getClickType() != net.minecraft.world.inventory.ClickType.QUICK_CRAFT) {
-                        if (click == ClickType.NUMBER_KEY) {
+                    if (packet.getClickType() != net.minecraft.world.inventory.ClickType.QUICK_CRAFT)
+                    {
+                        if (click == ClickType.NUMBER_KEY)
+                        {
                             event = new InventoryClickEvent(inventory, type, packet.getSlotNum(), click, action, packet.getButtonNum());
-                        } else {
+                        }
+                        else
+                        {
                             event = new InventoryClickEvent(inventory, type, packet.getSlotNum(), click, action);
                         }
 
                         org.bukkit.inventory.Inventory top = inventory.getTopInventory();
-                        if (packet.getSlotNum() == 0 && top instanceof CraftingInventory) {
+                        if (packet.getSlotNum() == 0 && top instanceof CraftingInventory)
+                        {
                             org.bukkit.inventory.Recipe recipe = ((CraftingInventory) top).getRecipe();
-                            if (recipe != null) {
-                                if (click == ClickType.NUMBER_KEY) {
+                            if (recipe != null)
+                            {
+                                if (click == ClickType.NUMBER_KEY)
+                                {
                                     event = new CraftItemEvent(recipe, inventory, type, packet.getSlotNum(), click, action, packet.getButtonNum());
-                                } else {
+                                }
+                                else
+                                {
                                     event = new CraftItemEvent(recipe, inventory, type, packet.getSlotNum(), click, action);
                                 }
                             }
                         }
 
-                        if (packet.getSlotNum() == 3 && top instanceof SmithingInventory) {
+                        if (packet.getSlotNum() == 3 && top instanceof SmithingInventory)
+                        {
                             org.bukkit.inventory.ItemStack result = ((SmithingInventory) top).getResult();
-                            if (result != null) {
-                                if (click == ClickType.NUMBER_KEY) {
+                            if (result != null)
+                            {
+                                if (click == ClickType.NUMBER_KEY)
+                                {
                                     event = new SmithItemEvent(inventory, type, packet.getSlotNum(), click, action, packet.getButtonNum());
-                                } else {
+                                }
+                                else
+                                {
                                     event = new SmithItemEvent(inventory, type, packet.getSlotNum(), click, action);
                                 }
                             }
                         }
 
                         // Paper start - cartography item event
-                        if (packet.getSlotNum() == net.minecraft.world.inventory.CartographyTableMenu.RESULT_SLOT && top instanceof org.bukkit.inventory.CartographyInventory cartographyInventory) {
+                        if (packet.getSlotNum() == net.minecraft.world.inventory.CartographyTableMenu.RESULT_SLOT && top instanceof org.bukkit.inventory.CartographyInventory cartographyInventory)
+                        {
                             org.bukkit.inventory.ItemStack result = cartographyInventory.getResult();
-                            if (result != null && !result.isEmpty()) {
-                                if (click == ClickType.NUMBER_KEY) {
+                            if (result != null && !result.isEmpty())
+                            {
+                                if (click == ClickType.NUMBER_KEY)
+                                {
                                     event = new io.papermc.paper.event.player.CartographyItemEvent(inventory, type, packet.getSlotNum(), click, action, packet.getButtonNum());
-                                } else {
+                                }
+                                else
+                                {
                                     event = new io.papermc.paper.event.player.CartographyItemEvent(inventory, type, packet.getSlotNum(), click, action);
                                 }
                             }
@@ -3199,11 +3790,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                         event.setCancelled(cancelled);
                         AbstractContainerMenu oldContainer = this.player.containerMenu; // SPIGOT-1224
                         this.cserver.getPluginManager().callEvent(event);
-                        if (this.player.containerMenu != oldContainer) {
+                        if (this.player.containerMenu != oldContainer)
+                        {
                             return;
                         }
 
-                        switch (event.getResult()) {
+                        switch (event.getResult())
+                        {
                             case ALLOW:
                             case DEFAULT:
                                 this.player.containerMenu.clicked(i, packet.getButtonNum(), packet.getClickType(), this.player);
@@ -3220,7 +3813,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                         this.player.playerConnection.sendPacket(new Packet103SetSlot(this.player.activeContainer.windowId, packet102windowclick.slot, this.player.activeContainer.getSlot(packet102windowclick.slot).getItem()));
                                     }
                                 }*/
-                                switch (action) {
+                                switch (action)
+                                {
                                     // Modified other slots
                                     case PICKUP_ALL:
                                     case MOVE_TO_OTHER_INVENTORY:
@@ -3258,7 +3852,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 }
                         }
 
-                        if (event instanceof CraftItemEvent || event instanceof SmithItemEvent) {
+                        if (event instanceof CraftItemEvent || event instanceof SmithItemEvent)
+                        {
                             // Need to update the inventory on crafting to
                             // correctly support custom recipes
                             this.player.containerMenu.sendAllDataToRemote();
@@ -3267,7 +3862,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                     // CraftBukkit end
                     ObjectIterator objectiterator = Int2ObjectMaps.fastIterable(packet.getChangedSlots()).iterator();
 
-                    while (objectiterator.hasNext()) {
+                    while (objectiterator.hasNext())
+                    {
                         Entry<ItemStack> entry = (Entry) objectiterator.next();
 
                         this.player.containerMenu.setRemoteSlotNoCopy(entry.getIntKey(), (ItemStack) entry.getValue());
@@ -3275,9 +3871,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                     this.player.containerMenu.setRemoteCarried(packet.getCarriedItem());
                     this.player.containerMenu.resumeRemoteUpdates();
-                    if (flag) {
+                    if (flag)
+                    {
                         this.player.containerMenu.broadcastFullState();
-                    } else {
+                    }
+                    else
+                    {
                         this.player.containerMenu.broadcastChanges();
                     }
 
@@ -3287,10 +3886,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handlePlaceRecipe(ServerboundPlaceRecipePacket packet) {
+    public void handlePlaceRecipe(ServerboundPlaceRecipePacket packet)
+    {
         // Paper start - auto recipe limit
-        if (!org.bukkit.Bukkit.isPrimaryThread()) {
-            if (this.recipeSpamPackets.addAndGet(io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.recipeSpamIncrement) > io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.recipeSpamLimit) {
+        if (!org.bukkit.Bukkit.isPrimaryThread())
+        {
+            if (this.recipeSpamPackets.addAndGet(io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.recipeSpamIncrement) > io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.recipeSpamLimit)
+            {
                 this.server.scheduleOnMain(() -> this.disconnect(net.minecraft.network.chat.Component.translatable("disconnect.spam"), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM)); // Paper - kick event cause
                 return;
             }
@@ -3298,34 +3900,42 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // Paper end - auto recipe limit
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         this.player.resetLastActionTime();
-        if (!this.player.isSpectator() && this.player.containerMenu.containerId == packet.getContainerId() && this.player.containerMenu instanceof RecipeBookMenu) {
-            if (!this.player.containerMenu.stillValid(this.player)) {
+        if (!this.player.isSpectator() && this.player.containerMenu.containerId == packet.getContainerId() && this.player.containerMenu instanceof RecipeBookMenu)
+        {
+            if (!this.player.containerMenu.stillValid(this.player))
+            {
                 ServerGamePacketListenerImpl.LOGGER.debug("Player {} interacted with invalid menu {}", this.player, this.player.containerMenu);
-            } else {
+            }
+            else
+            {
                 // Paper start - Add PlayerRecipeBookClickEvent
                 ResourceLocation recipeName = packet.getRecipe();
                 boolean makeAll = packet.isShiftDown();
                 com.destroystokyo.paper.event.player.PlayerRecipeBookClickEvent paperEvent = new com.destroystokyo.paper.event.player.PlayerRecipeBookClickEvent(
                     this.player.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(recipeName), makeAll
                 );
-                if (!paperEvent.callEvent()) {
+                if (!paperEvent.callEvent())
+                {
                     return;
                 }
                 recipeName = CraftNamespacedKey.toMinecraft(paperEvent.getRecipe());
                 makeAll = paperEvent.isMakeAll();
-                if (org.bukkit.event.player.PlayerRecipeBookClickEvent.getHandlerList().getRegisteredListeners().length > 0) {
-                // Paper end - Add PlayerRecipeBookClickEvent
-                // CraftBukkit start - implement PlayerRecipeBookClickEvent
-                org.bukkit.inventory.Recipe recipe = this.cserver.getRecipe(CraftNamespacedKey.fromMinecraft(recipeName)); // Paper
-                if (recipe == null) {
-                    return;
-                }
-                // Paper start - Add PlayerRecipeBookClickEvent
-                org.bukkit.event.player.PlayerRecipeBookClickEvent event = CraftEventFactory.callRecipeBookClickEvent(this.player, recipe, makeAll);
-                recipeName = CraftNamespacedKey.toMinecraft(((org.bukkit.Keyed) event.getRecipe()).getKey());
-                makeAll = event.isShiftClick();
+                if (org.bukkit.event.player.PlayerRecipeBookClickEvent.getHandlerList().getRegisteredListeners().length > 0)
+                {
+                    // Paper end - Add PlayerRecipeBookClickEvent
+                    // CraftBukkit start - implement PlayerRecipeBookClickEvent
+                    org.bukkit.inventory.Recipe recipe = this.cserver.getRecipe(CraftNamespacedKey.fromMinecraft(recipeName)); // Paper
+                    if (recipe == null)
+                    {
+                        return;
+                    }
+                    // Paper start - Add PlayerRecipeBookClickEvent
+                    org.bukkit.event.player.PlayerRecipeBookClickEvent event = CraftEventFactory.callRecipeBookClickEvent(this.player, recipe, makeAll);
+                    recipeName = CraftNamespacedKey.toMinecraft(((org.bukkit.Keyed) event.getRecipe()).getKey());
+                    makeAll = event.isShiftClick();
                 }
-                if (!(this.player.containerMenu instanceof RecipeBookMenu<?> recipeBookMenu)) {
+                if (!(this.player.containerMenu instanceof RecipeBookMenu<?> recipeBookMenu))
+                {
                     return;
                 }
                 // Paper end - Add PlayerRecipeBookClickEvent
@@ -3333,7 +3943,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 // Cast to keyed should be safe as the recipe will never be a MerchantRecipe.
                 // Paper start - Add PlayerRecipeBookClickEvent
                 final boolean finalMakeAll = makeAll;
-                this.server.getRecipeManager().byKey(recipeName).ifPresent((recipeholder) -> {
+                this.server.getRecipeManager().byKey(recipeName).ifPresent((recipeholder) ->
+                {
                     recipeBookMenu.handlePlacement(finalMakeAll, recipeholder, this.player);
                     // Paper end - Add PlayerRecipeBookClickEvent
                 });
@@ -3343,17 +3954,26 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleContainerButtonClick(ServerboundContainerButtonClickPacket packet) {
+    public void handleContainerButtonClick(ServerboundContainerButtonClickPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.isImmobile()) return; // CraftBukkit
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
         this.player.resetLastActionTime();
-        if (this.player.containerMenu.containerId == packet.containerId() && !this.player.isSpectator()) {
-            if (!this.player.containerMenu.stillValid(this.player)) {
+        if (this.player.containerMenu.containerId == packet.containerId() && !this.player.isSpectator())
+        {
+            if (!this.player.containerMenu.stillValid(this.player))
+            {
                 ServerGamePacketListenerImpl.LOGGER.debug("Player {} interacted with invalid menu {}", this.player, this.player.containerMenu);
-            } else {
+            }
+            else
+            {
                 boolean flag = this.player.containerMenu.clickMenuButton(this.player, packet.buttonId());
 
-                if (flag) {
+                if (flag)
+                {
                     this.player.containerMenu.broadcastChanges();
                 }
 
@@ -3362,30 +3982,37 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSetCreativeModeSlot(ServerboundSetCreativeModeSlotPacket packet) {
+    public void handleSetCreativeModeSlot(ServerboundSetCreativeModeSlotPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.gameMode.isCreative()) {
+        if (this.player.gameMode.isCreative())
+        {
             boolean flag = packet.slotNum() < 0;
             ItemStack itemstack = packet.itemStack();
 
-            if (!itemstack.isItemEnabled(this.player.level().enabledFeatures())) {
+            if (!itemstack.isItemEnabled(this.player.level().enabledFeatures()))
+            {
                 return;
             }
 
             CustomData customdata = (CustomData) itemstack.getOrDefault(DataComponents.BLOCK_ENTITY_DATA, CustomData.EMPTY);
 
-            if (customdata.contains("x") && customdata.contains("y") && customdata.contains("z") && this.player.getBukkitEntity().hasPermission("minecraft.nbt.copy")) { // Spigot
+            if (customdata.contains("x") && customdata.contains("y") && customdata.contains("z") && this.player.getBukkitEntity().hasPermission("minecraft.nbt.copy"))
+            { // Spigot
                 BlockPos blockposition = BlockEntity.getPosFromTag(customdata.getUnsafe());
 
-                if (this.player.level().isLoaded(blockposition)) {
+                if (this.player.level().isLoaded(blockposition))
+                {
                     // Paper start - Prevent tile entity copies loading chunks
                     BlockEntity tileentity = null;
-                    if (this.player.distanceToSqr(blockposition.getX(), blockposition.getY(), blockposition.getZ()) < 32 * 32 && this.player.serverLevel().isLoadedAndInBounds(blockposition)) {
+                    if (this.player.distanceToSqr(blockposition.getX(), blockposition.getY(), blockposition.getZ()) < 32 * 32 && this.player.serverLevel().isLoadedAndInBounds(blockposition))
+                    {
                         tileentity = this.player.level().getBlockEntity(blockposition);
                     }
                     // Paper end - Prevent tile entity copies loading chunks
 
-                    if (tileentity != null) {
+                    if (tileentity != null)
+                    {
                         tileentity.saveToItem(itemstack, this.player.level().registryAccess());
                     }
                 }
@@ -3393,18 +4020,25 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
             boolean flag1 = packet.slotNum() >= 1 && packet.slotNum() <= 45;
             boolean flag2 = itemstack.isEmpty() || itemstack.getCount() <= itemstack.getMaxStackSize();
-            if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.slotNum()).getItem(), packet.itemStack()))) { // Insist on valid slot
+            if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.slotNum()).getItem(), packet.itemStack())))
+            { // Insist on valid slot
                 // CraftBukkit start - Call click event
                 InventoryView inventory = this.player.inventoryMenu.getBukkitView();
                 org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packet.itemStack());
 
                 SlotType type = SlotType.QUICKBAR;
-                if (flag) {
+                if (flag)
+                {
                     type = SlotType.OUTSIDE;
-                } else if (packet.slotNum() < 36) {
-                    if (packet.slotNum() >= 5 && packet.slotNum() < 9) {
+                }
+                else if (packet.slotNum() < 36)
+                {
+                    if (packet.slotNum() >= 5 && packet.slotNum() < 9)
+                    {
                         type = SlotType.ARMOR;
-                    } else {
+                    }
+                    else
+                    {
                         type = SlotType.CONTAINER;
                     }
                 }
@@ -3413,28 +4047,33 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 itemstack = CraftItemStack.asNMSCopy(event.getCursor());
 
-                switch (event.getResult()) {
-                case ALLOW:
-                    // Plugin cleared the id / stacksize checks
-                    flag2 = true;
-                    break;
-                case DEFAULT:
-                    break;
-                case DENY:
-                    // Reset the slot
-                    if (packet.slotNum() >= 0) {
-                        this.player.connection.send(new ClientboundContainerSetSlotPacket(this.player.inventoryMenu.containerId, this.player.inventoryMenu.incrementStateId(), packet.slotNum(), this.player.inventoryMenu.getSlot(packet.slotNum()).getItem()));
-                        this.player.connection.send(new ClientboundContainerSetSlotPacket(-1, this.player.inventoryMenu.incrementStateId(), -1, ItemStack.EMPTY));
-                    }
-                    return;
+                switch (event.getResult())
+                {
+                    case ALLOW:
+                        // Plugin cleared the id / stacksize checks
+                        flag2 = true;
+                        break;
+                    case DEFAULT:
+                        break;
+                    case DENY:
+                        // Reset the slot
+                        if (packet.slotNum() >= 0)
+                        {
+                            this.player.connection.send(new ClientboundContainerSetSlotPacket(this.player.inventoryMenu.containerId, this.player.inventoryMenu.incrementStateId(), packet.slotNum(), this.player.inventoryMenu.getSlot(packet.slotNum()).getItem()));
+                            this.player.connection.send(new ClientboundContainerSetSlotPacket(-1, this.player.inventoryMenu.incrementStateId(), -1, ItemStack.EMPTY));
+                        }
+                        return;
                 }
             }
             // CraftBukkit end
 
-            if (flag1 && flag2) {
+            if (flag1 && flag2)
+            {
                 this.player.inventoryMenu.getSlot(packet.slotNum()).setByPlayer(itemstack);
                 this.player.inventoryMenu.broadcastChanges();
-            } else if (flag && flag2 && this.dropSpamTickCount < 200) {
+            }
+            else if (flag && flag2 && this.dropSpamTickCount < 200)
+            {
                 this.dropSpamTickCount += 20;
                 this.player.drop(itemstack, true);
             }
@@ -3443,14 +4082,18 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleSignUpdate(ServerboundSignUpdatePacket packet) {
+    public void handleSignUpdate(ServerboundSignUpdatePacket packet)
+    {
         // Paper start - Limit client sign length
         String[] lines = packet.getLines();
-        for (int i = 0; i < lines.length; ++i) {
-            if (MAX_SIGN_LINE_LENGTH > 0 && lines[i].length() > MAX_SIGN_LINE_LENGTH) {
+        for (int i = 0; i < lines.length; ++i)
+        {
+            if (MAX_SIGN_LINE_LENGTH > 0 && lines[i].length() > MAX_SIGN_LINE_LENGTH)
+            {
                 // This handles multibyte characters as 1
                 int offset = lines[i].codePoints().limit(MAX_SIGN_LINE_LENGTH).map(Character::charCount).sum();
-                if (offset < lines[i].length()) {
+                if (offset < lines[i].length())
+                {
                     lines[i] = lines[i].substring(0, offset); // this will break any filtering, but filtering is NYI as of 1.17
                 }
             }
@@ -3458,21 +4101,28 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         List<String> list = (List) Stream.of(lines).map(ChatFormatting::stripFormatting).collect(Collectors.toList());
         // Paper end - Limit client sign length
 
-        this.filterTextPacket(list).thenAcceptAsync((list1) -> {
+        this.filterTextPacket(list).thenAcceptAsync((list1) ->
+        {
             this.updateSignText(packet, list1);
         }, this.server);
     }
 
-    private void updateSignText(ServerboundSignUpdatePacket packet, List<FilteredText> signText) {
-        if (this.player.isImmobile()) return; // CraftBukkit
+    private void updateSignText(ServerboundSignUpdatePacket packet, List<FilteredText> signText)
+    {
+        if (this.player.isImmobile())
+        {
+            return; // CraftBukkit
+        }
         this.player.resetLastActionTime();
         ServerLevel worldserver = this.player.serverLevel();
         BlockPos blockposition = packet.getPos();
 
-        if (worldserver.hasChunkAt(blockposition)) {
+        if (worldserver.hasChunkAt(blockposition))
+        {
             BlockEntity tileentity = worldserver.getBlockEntity(blockposition);
 
-            if (!(tileentity instanceof SignBlockEntity)) {
+            if (!(tileentity instanceof SignBlockEntity))
+            {
                 return;
             }
 
@@ -3484,15 +4134,20 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket packet) {
+    public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         // CraftBukkit start
-        if (this.player.getAbilities().mayfly && this.player.getAbilities().flying != packet.isFlying()) {
+        if (this.player.getAbilities().mayfly && this.player.getAbilities().flying != packet.isFlying())
+        {
             PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.player.getBukkitEntity(), packet.isFlying());
             this.cserver.getPluginManager().callEvent(event);
-            if (!event.isCancelled()) {
+            if (!event.isCancelled())
+            {
                 this.player.getAbilities().flying = packet.isFlying(); // Actually set the player's flying status
-            } else {
+            }
+            else
+            {
                 this.player.onUpdateAbilities(); // Tell the player their ability was reverted
             }
         }
@@ -3500,10 +4155,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleClientInformation(ServerboundClientInformationPacket packet) {
+    public void handleClientInformation(ServerboundClientInformationPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         // Paper start - do not accept invalid information
-        if (packet.information().viewDistance() < 0) {
+        if (packet.information().viewDistance() < 0)
+        {
             LOGGER.warn("Disconnecting " + this.player.getScoreboardName() + " for invalid view distance: " + packet.information().viewDistance());
             this.disconnect("Invalid client settings", org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION);
             return;
@@ -3514,42 +4171,55 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleChangeDifficulty(ServerboundChangeDifficultyPacket packet) {
+    public void handleChangeDifficulty(ServerboundChangeDifficultyPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.hasPermissions(2) || this.isSingleplayerOwner()) {
+        if (this.player.hasPermissions(2) || this.isSingleplayerOwner())
+        {
             // this.server.setDifficulty(packet.getDifficulty(), false); // Paper - per level difficulty; don't allow clients to change this
         }
     }
 
     @Override
-    public void handleLockDifficulty(ServerboundLockDifficultyPacket packet) {
+    public void handleLockDifficulty(ServerboundLockDifficultyPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
-        if (this.player.hasPermissions(2) || this.isSingleplayerOwner()) {
+        if (this.player.hasPermissions(2) || this.isSingleplayerOwner())
+        {
             this.server.setDifficultyLocked(packet.isLocked());
         }
     }
 
     @Override
-    public void handleChatSessionUpdate(ServerboundChatSessionUpdatePacket packet) {
+    public void handleChatSessionUpdate(ServerboundChatSessionUpdatePacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         RemoteChatSession.Data remotechatsession_a = packet.chatSession();
         ProfilePublicKey.Data profilepublickey_a = this.chatSession != null ? this.chatSession.profilePublicKey().data() : null;
         ProfilePublicKey.Data profilepublickey_a1 = remotechatsession_a.profilePublicKey();
 
-        if (!Objects.equals(profilepublickey_a, profilepublickey_a1)) {
-            if (profilepublickey_a != null && profilepublickey_a1.expiresAt().isBefore(profilepublickey_a.expiresAt())) {
+        if (!Objects.equals(profilepublickey_a, profilepublickey_a1))
+        {
+            if (profilepublickey_a != null && profilepublickey_a1.expiresAt().isBefore(profilepublickey_a.expiresAt()))
+            {
                 this.disconnect(ProfilePublicKey.EXPIRED_PROFILE_PUBLIC_KEY, org.bukkit.event.player.PlayerKickEvent.Cause.EXPIRED_PROFILE_PUBLIC_KEY); // Paper - kick event causes
-            } else {
-                try {
+            }
+            else
+            {
+                try
+                {
                     SignatureValidator signaturevalidator = this.server.getProfileKeySignatureValidator();
 
-                    if (signaturevalidator == null) {
+                    if (signaturevalidator == null)
+                    {
                         ServerGamePacketListenerImpl.LOGGER.warn("Ignoring chat session from {} due to missing Services public key", this.player.getGameProfile().getName());
                         return;
                     }
 
                     this.resetPlayerChatState(remotechatsession_a.validate(this.player.getGameProfile(), signaturevalidator));
-                } catch (ProfilePublicKey.ValidationException profilepublickey_b) {
+                }
+                catch (ProfilePublicKey.ValidationException profilepublickey_b)
+                {
                     // ServerGamePacketListenerImpl.LOGGER.error("Failed to validate profile key: {}", profilepublickey_b.getMessage()); // Paper - Improve logging and errors
                     this.disconnect(profilepublickey_b.getComponent(), profilepublickey_b.kickCause); // Paper - kick event causes
                 }
@@ -3559,31 +4229,39 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     @Override
-    public void handleConfigurationAcknowledged(ServerboundConfigurationAcknowledgedPacket packet) {
-        if (!this.waitingForSwitchToConfig) {
+    public void handleConfigurationAcknowledged(ServerboundConfigurationAcknowledgedPacket packet)
+    {
+        if (!this.waitingForSwitchToConfig)
+        {
             throw new IllegalStateException("Client acknowledged config, but none was requested");
-        } else {
+        }
+        else
+        {
             this.connection.setupInboundProtocol(ConfigurationProtocols.SERVERBOUND, new ServerConfigurationPacketListenerImpl(this.server, this.connection, this.createCookie(this.player.clientInformation()), this.player)); // CraftBukkit
         }
     }
 
     @Override
-    public void handleChunkBatchReceived(ServerboundChunkBatchReceivedPacket packet) {
+    public void handleChunkBatchReceived(ServerboundChunkBatchReceivedPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         this.chunkSender.onChunkBatchReceivedByClient(packet.desiredChunksPerTick());
     }
 
     @Override
-    public void handleDebugSampleSubscription(ServerboundDebugSampleSubscriptionPacket packet) {
+    public void handleDebugSampleSubscription(ServerboundDebugSampleSubscriptionPacket packet)
+    {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         this.server.subscribeToDebugSample(this.player, packet.sampleType());
     }
 
-    private void resetPlayerChatState(RemoteChatSession session) {
+    private void resetPlayerChatState(RemoteChatSession session)
+    {
         this.chatSession = session;
         this.hasLoggedExpiry = false; // Paper - Prevent causing expired keys from impacting new joins
         this.signedMessageDecoder = session.createMessageDecoder(this.player.getUUID());
-        this.chatMessageChain.append(() -> {
+        this.chatMessageChain.append(() ->
+        {
             this.player.setChatSession(session);
             this.server.getPlayerList().broadcastAll(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.INITIALIZE_CHAT), List.of(this.player)), this.player); // Paper - Use single player info update packet on join
         });
@@ -3595,19 +4273,22 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // CraftBukkit end
 
     @Override
-    public ServerPlayer getPlayer() {
+    public ServerPlayer getPlayer()
+    {
         return this.player;
     }
 
     @FunctionalInterface
-    private interface EntityInteraction {
+    private interface EntityInteraction
+    {
 
         InteractionResult run(ServerPlayer player, Entity entity, InteractionHand hand);
     }
 
     // Paper start - Add fail move event
     private io.papermc.paper.event.player.PlayerFailMoveEvent fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason failReason,
-                                                                           double toX, double toY, double toZ, float toYaw, float toPitch, boolean logWarning) {
+                                                                           double toX, double toY, double toZ, float toYaw, float toPitch, boolean logWarning)
+    {
         Player player = this.getCraftPlayer();
         Location from = new Location(player.getWorld(), this.lastPosX, this.lastPosY, this.lastPosZ, this.lastYaw, this.lastPitch);
         Location to = new Location(player.getWorld(), toX, toY, toZ, toYaw, toPitch);
