From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taah <admin@taah.dev>
Date: Thu, 9 May 2024 23:17:13 -0700
Subject: [PATCH] Fix out of bound hangingentity crash exploit


diff --git a/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java b/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
index bf2d91bbb4bf401696f5f5d14a67e3920a179084..a1c918b0f221048cade77627d1216c02fcb88bdc 100644
--- a/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
@@ -1,8 +1,13 @@
 package net.minecraft.world.entity.decoration;
 
 import com.mojang.logging.LogUtils;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.DamageTypeTags;
+import net.minecraft.util.Mth;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
@@ -19,45 +24,53 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.apache.commons.lang3.Validate;
-import org.slf4j.Logger;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.network.syncher.SynchedEntityData;
-import net.minecraft.server.level.ServerLevel;
-// CraftBukkit start
-import net.minecraft.tags.DamageTypeTags;
-import net.minecraft.util.Mth;
 import org.bukkit.entity.Hanging;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.hanging.HangingBreakEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.function.Predicate;
 // CraftBukkit end
 
-public abstract class HangingEntity extends Entity {
+public abstract class HangingEntity extends Entity
+{
 
     private static final Logger LOGGER = LogUtils.getLogger();
-    protected static final Predicate<Entity> HANGING_ENTITY = (entity) -> {
+    protected static final Predicate<Entity> HANGING_ENTITY = (entity) ->
+    {
         return entity instanceof HangingEntity;
     };
-    private int checkInterval; { this.checkInterval = this.getId() % this.level().spigotConfig.hangingTickFrequency; } // Paper - Perf: offset item frame ticking
+    private int checkInterval;
+
+    {
+        this.checkInterval = this.getId() % this.level().spigotConfig.hangingTickFrequency;
+    } // Paper - Perf: offset item frame ticking
+
     public BlockPos pos;
     protected Direction direction;
 
-    protected HangingEntity(EntityType<? extends HangingEntity> type, Level world) {
+    protected HangingEntity(EntityType<? extends HangingEntity> type, Level world)
+    {
         super(type, world);
         this.direction = Direction.SOUTH;
     }
 
-    protected HangingEntity(EntityType<? extends HangingEntity> type, Level world, BlockPos pos) {
+    protected HangingEntity(EntityType<? extends HangingEntity> type, Level world, BlockPos pos)
+    {
         this(type, world);
         this.pos = pos;
     }
 
     @Override
-    protected void defineSynchedData(SynchedEntityData.Builder builder) {}
+    protected void defineSynchedData(SynchedEntityData.Builder builder)
+    {
+    }
 
-    public void setDirection(Direction facing) {
+    public void setDirection(Direction facing)
+    {
         Validate.notNull(facing);
         Validate.isTrue(facing.getAxis().isHorizontal());
         this.direction = facing;
@@ -66,8 +79,10 @@ public abstract class HangingEntity extends Entity {
         this.recalculateBoundingBox();
     }
 
-    protected void recalculateBoundingBox() {
-        if (this.direction != null) {
+    protected void recalculateBoundingBox()
+    {
+        if (this.direction != null)
+        {
             // CraftBukkit start code moved in to calculateBoundingBox
             this.setBoundingBox(HangingEntity.calculateBoundingBox(this, this.pos, this.direction, this.getWidth(), this.getHeight()));
             // CraftBukkit end
@@ -75,7 +90,8 @@ public abstract class HangingEntity extends Entity {
     }
 
     // CraftBukkit start - break out BB calc into own method
-    public static AABB calculateBoundingBox(@Nullable Entity entity, BlockPos blockPosition, Direction direction, int width, int height) {
+    public static AABB calculateBoundingBox(@Nullable Entity entity, BlockPos blockPosition, Direction direction, int width, int height)
+    {
         {
             double d0 = (double) blockPosition.getX() + 0.5D;
             double d1 = (double) blockPosition.getY() + 0.5D;
@@ -91,16 +107,20 @@ public abstract class HangingEntity extends Entity {
 
             d0 += d4 * (double) enumdirection.getStepX();
             d2 += d4 * (double) enumdirection.getStepZ();
-            if (entity != null) {
+            if (entity != null)
+            {
                 entity.setPosRaw(d0, d1, d2);
             }
             double d6 = (double) width;
             double d7 = (double) height;
             double d8 = (double) width;
 
-            if (direction.getAxis() == Direction.Axis.Z) {
+            if (direction.getAxis() == Direction.Axis.Z)
+            {
                 d8 = 1.0D;
-            } else {
+            }
+            else
+            {
                 d6 = 1.0D;
             }
 
@@ -112,32 +132,41 @@ public abstract class HangingEntity extends Entity {
     }
     // CraftBukkit end
 
-    private static double offs(int i) { // CraftBukkit - static
+    private static double offs(int i)
+    { // CraftBukkit - static
         return i % 32 == 0 ? 0.5D : 0.0D;
     }
 
     @Override
-    public void tick() {
-        if (!this.level().isClientSide) {
+    public void tick()
+    {
+        if (!this.level().isClientSide)
+        {
             this.checkBelowWorld();
-            if (this.checkInterval++ == this.level().spigotConfig.hangingTickFrequency) { // Spigot
+            if (this.checkInterval++ == this.level().spigotConfig.hangingTickFrequency)
+            { // Spigot
                 this.checkInterval = 0;
-                if (!this.isRemoved() && !this.survives()) {
+                if (!this.isRemoved() && !this.survives())
+                {
                     // CraftBukkit start - fire break events
                     BlockState material = this.level().getBlockState(this.blockPosition());
                     HangingBreakEvent.RemoveCause cause;
 
-                    if (!material.isAir()) {
+                    if (!material.isAir())
+                    {
                         // TODO: This feels insufficient to catch 100% of suffocation cases
                         cause = HangingBreakEvent.RemoveCause.OBSTRUCTION;
-                    } else {
+                    }
+                    else
+                    {
                         cause = HangingBreakEvent.RemoveCause.PHYSICS;
                     }
 
                     HangingBreakEvent event = new HangingBreakEvent((Hanging) this.getBukkitEntity(), cause);
                     this.level().getCraftServer().getPluginManager().callEvent(event);
 
-                    if (this.isRemoved() || event.isCancelled()) {
+                    if (this.isRemoved() || event.isCancelled())
+                    {
                         return;
                     }
                     // CraftBukkit end
@@ -149,25 +178,32 @@ public abstract class HangingEntity extends Entity {
 
     }
 
-    public boolean survives() {
-        if (!this.level().noCollision((Entity) this)) {
+    public boolean survives()
+    {
+        if (!this.level().noCollision((Entity) this))
+        {
             return false;
-        } else {
+        }
+        else
+        {
             int i = Math.max(1, this.getWidth() / 16);
             int j = Math.max(1, this.getHeight() / 16);
             BlockPos blockposition = this.pos.relative(this.direction.getOpposite());
             Direction enumdirection = this.direction.getCounterClockWise();
             BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-            for (int k = 0; k < i; ++k) {
-                for (int l = 0; l < j; ++l) {
+            for (int k = 0; k < i; ++k)
+            {
+                for (int l = 0; l < j; ++l)
+                {
                     int i1 = (i - 1) / -2;
                     int j1 = (j - 1) / -2;
 
                     blockposition_mutableblockposition.set(blockposition).move(enumdirection, k + i1).move(Direction.UP, l + j1);
                     BlockState iblockdata = this.level().getBlockState(blockposition_mutableblockposition);
 
-                    if (!iblockdata.isSolid() && !DiodeBlock.isDiode(iblockdata)) {
+                    if (!iblockdata.isSolid() && !DiodeBlock.isDiode(iblockdata))
+                    {
                         return false;
                     }
                 }
@@ -178,42 +214,57 @@ public abstract class HangingEntity extends Entity {
     }
 
     @Override
-    public boolean isPickable() {
+    public boolean isPickable()
+    {
         return true;
     }
 
     @Override
-    public boolean skipAttackInteraction(Entity attacker) {
-        if (attacker instanceof Player entityhuman) {
+    public boolean skipAttackInteraction(Entity attacker)
+    {
+        if (attacker instanceof Player entityhuman)
+        {
             return !this.level().mayInteract(entityhuman, this.pos) ? true : this.hurt(this.damageSources().playerAttack(entityhuman), 0.0F);
-        } else {
+        }
+        else
+        {
             return false;
         }
     }
 
     @Override
-    public Direction getDirection() {
+    public Direction getDirection()
+    {
         return this.direction;
     }
 
     @Override
-    public boolean hurt(DamageSource source, float amount) {
-        if (this.isInvulnerableTo(source)) {
+    public boolean hurt(DamageSource source, float amount)
+    {
+        if (this.isInvulnerableTo(source))
+        {
             return false;
-        } else {
-            if (!this.isRemoved() && !this.level().isClientSide) {
+        }
+        else
+        {
+            if (!this.isRemoved() && !this.level().isClientSide)
+            {
                 // CraftBukkit start - fire break events
                 Entity damager = (source.isIndirect() && source.getEntity() != null) ? source.getEntity() : source.getDirectEntity(); // Paper - fix DamageSource API
                 HangingBreakEvent event;
-                if (damager != null) {
+                if (damager != null)
+                {
                     event = new HangingBreakByEntityEvent((Hanging) this.getBukkitEntity(), damager.getBukkitEntity(), source.is(DamageTypeTags.IS_EXPLOSION) ? HangingBreakEvent.RemoveCause.EXPLOSION : HangingBreakEvent.RemoveCause.ENTITY);
-                } else {
+                }
+                else
+                {
                     event = new HangingBreakEvent((Hanging) this.getBukkitEntity(), source.is(DamageTypeTags.IS_EXPLOSION) ? HangingBreakEvent.RemoveCause.EXPLOSION : HangingBreakEvent.RemoveCause.DEFAULT);
                 }
 
                 this.level().getCraftServer().getPluginManager().callEvent(event);
 
-                if (this.isRemoved() || event.isCancelled()) {
+                if (this.isRemoved() || event.isCancelled())
+                {
                     return true;
                 }
                 // CraftBukkit end
@@ -228,16 +279,22 @@ public abstract class HangingEntity extends Entity {
     }
 
     @Override
-    public void move(MoverType movementType, Vec3 movement) {
-        if (!this.level().isClientSide && !this.isRemoved() && movement.lengthSqr() > 0.0D) {
-            if (this.isRemoved()) return; // CraftBukkit
+    public void move(MoverType movementType, Vec3 movement)
+    {
+        if (!this.level().isClientSide && !this.isRemoved() && movement.lengthSqr() > 0.0D)
+        {
+            if (this.isRemoved())
+            {
+                return; // CraftBukkit
+            }
 
             // CraftBukkit start - fire break events
             // TODO - Does this need its own cause? Seems to only be triggered by pistons
             HangingBreakEvent event = new HangingBreakEvent((Hanging) this.getBukkitEntity(), HangingBreakEvent.RemoveCause.PHYSICS);
             this.level().getCraftServer().getPluginManager().callEvent(event);
 
-            if (this.isRemoved() || event.isCancelled()) {
+            if (this.isRemoved() || event.isCancelled())
+            {
                 return;
             }
             // CraftBukkit end
@@ -249,8 +306,10 @@ public abstract class HangingEntity extends Entity {
     }
 
     @Override
-    public void push(double deltaX, double deltaY, double deltaZ, @org.jetbrains.annotations.Nullable Entity pushingEntity) { // Paper - add push source entity param
-        if (false && !this.level().isClientSide && !this.isRemoved() && deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ > 0.0D) { // CraftBukkit - not needed
+    public void push(double deltaX, double deltaY, double deltaZ, @org.jetbrains.annotations.Nullable Entity pushingEntity)
+    { // Paper - add push source entity param
+        if (false && !this.level().isClientSide && !this.isRemoved() && deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ > 0.0D)
+        { // CraftBukkit - not needed
             this.kill();
             this.dropItem((Entity) null);
         }
@@ -259,15 +318,18 @@ public abstract class HangingEntity extends Entity {
 
     // CraftBukkit start - selectively save tile position
     @Override
-    public void addAdditionalSaveData(CompoundTag nbttagcompound, boolean includeAll) {
-        if (includeAll) {
+    public void addAdditionalSaveData(CompoundTag nbttagcompound, boolean includeAll)
+    {
+        if (includeAll)
+        {
             this.addAdditionalSaveData(nbttagcompound);
         }
     }
     // CraftBukkit end
 
     @Override
-    public void addAdditionalSaveData(CompoundTag nbt) {
+    public void addAdditionalSaveData(CompoundTag nbt)
+    {
         BlockPos blockposition = this.getPos();
 
         nbt.putInt("TileX", blockposition.getX());
@@ -276,12 +338,31 @@ public abstract class HangingEntity extends Entity {
     }
 
     @Override
-    public void readAdditionalSaveData(CompoundTag nbt) {
+    public void readAdditionalSaveData(CompoundTag nbt)
+    {
         BlockPos blockposition = new BlockPos(nbt.getInt("TileX"), nbt.getInt("TileY"), nbt.getInt("TileZ"));
 
-        if (!blockposition.closerThan(this.blockPosition(), 16.0D)) {
+        // Scissors start - Fixes exploit where bad TileX, TileY, and TileZ coordinates can crash servers
+
+        try (Level level = level())
+        {
+            if (level.isLoadedAndInBounds(blockposition))
+            {
+                this.pos = blockposition;
+            }
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException(e);
+        }
+        // Scissors end
+
+        if (!blockposition.closerThan(this.blockPosition(), 16.0D))
+        {
             HangingEntity.LOGGER.error("Hanging entity at invalid position: {}", blockposition);
-        } else {
+        }
+        else
+        {
             this.pos = blockposition;
         }
     }
@@ -295,7 +376,8 @@ public abstract class HangingEntity extends Entity {
     public abstract void playPlacementSound();
 
     @Override
-    public ItemEntity spawnAtLocation(ItemStack stack, float yOffset) {
+    public ItemEntity spawnAtLocation(ItemStack stack, float yOffset)
+    {
         ItemEntity entityitem = new ItemEntity(this.level(), this.getX() + (double) ((float) this.direction.getStepX() * 0.15F), this.getY() + (double) yOffset, this.getZ() + (double) ((float) this.direction.getStepZ() * 0.15F), stack);
 
         entityitem.setDefaultPickUpDelay();
@@ -304,25 +386,31 @@ public abstract class HangingEntity extends Entity {
     }
 
     @Override
-    protected boolean repositionEntityAfterLoad() {
+    protected boolean repositionEntityAfterLoad()
+    {
         return false;
     }
 
     @Override
-    public void setPos(double x, double y, double z) {
+    public void setPos(double x, double y, double z)
+    {
         this.pos = BlockPos.containing(x, y, z);
         this.recalculateBoundingBox();
         this.hasImpulse = true;
     }
 
-    public BlockPos getPos() {
+    public BlockPos getPos()
+    {
         return this.pos;
     }
 
     @Override
-    public float rotate(Rotation rotation) {
-        if (this.direction.getAxis() != Direction.Axis.Y) {
-            switch (rotation) {
+    public float rotate(Rotation rotation)
+    {
+        if (this.direction.getAxis() != Direction.Axis.Y)
+        {
+            switch (rotation)
+            {
                 case CLOCKWISE_180:
                     this.direction = this.direction.getOpposite();
                     break;
@@ -336,7 +424,8 @@ public abstract class HangingEntity extends Entity {
 
         float f = Mth.wrapDegrees(this.getYRot());
 
-        switch (rotation) {
+        switch (rotation)
+        {
             case CLOCKWISE_180:
                 return f + 180.0F;
             case COUNTERCLOCKWISE_90:
@@ -349,13 +438,18 @@ public abstract class HangingEntity extends Entity {
     }
 
     @Override
-    public float mirror(Mirror mirror) {
+    public float mirror(Mirror mirror)
+    {
         return this.rotate(mirror.getRotation(this.direction));
     }
 
     @Override
-    public void thunderHit(ServerLevel world, LightningBolt lightning) {}
+    public void thunderHit(ServerLevel world, LightningBolt lightning)
+    {
+    }
 
     @Override
-    public void refreshDimensions() {}
+    public void refreshDimensions()
+    {
+    }
 }
